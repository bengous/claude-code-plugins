#!/usr/bin/env bash
set -euo pipefail

# ================================================================
# settings-manager - Claude Code JSONC settings management
# ================================================================
# Flag-driven script for setting up and managing JSONC settings.
# Claude handles decision-making; this script handles execution.
# ================================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
NC='\033[0m'

# Configuration
SCHEMA_URL="https://json.schemastore.org/claude-code-settings.json"
CACHE_DIR="${HOME}/.cache/claude-settings-manager"
CACHE_TTL=86400  # 24 hours

# Script location (for --install-global)
SCRIPT_PATH="${BASH_SOURCE[0]}"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# ================================================================
# JSONC Parser (inline node - strips comments)
# ================================================================
strip_jsonc() {
  node -e '
    const fs = require("fs");
    const input = fs.readFileSync(process.argv[1], "utf8");

    let result = "";
    let inString = false;
    let stringChar = "";
    let i = 0;

    while (i < input.length) {
      if (!inString && input[i] === "\"") {
        inString = true;
        stringChar = input[i];
        result += input[i];
        i++;
        continue;
      }

      if (inString) {
        if (input[i] === "\\" && i + 1 < input.length) {
          result += input[i] + input[i + 1];
          i += 2;
          continue;
        }
        if (input[i] === stringChar) {
          inString = false;
        }
        result += input[i];
        i++;
        continue;
      }

      if (input[i] === "/" && i + 1 < input.length) {
        if (input[i + 1] === "/") {
          while (i < input.length && input[i] !== "\n") i++;
          continue;
        }
        if (input[i + 1] === "*") {
          i += 2;
          while (i + 1 < input.length && !(input[i] === "*" && input[i + 1] === "/")) i++;
          i += 2;
          continue;
        }
      }

      result += input[i];
      i++;
    }

    try {
      const obj = JSON.parse(result);
      console.log(JSON.stringify(obj, null, 2));
    } catch (e) {
      console.error("JSONC parse error:", e.message);
      process.exit(1);
    }
  ' "$1"
}

# ================================================================
# Commands
# ================================================================

# Sync JSONC to JSON
cmd_sync() {
  local source_file=""
  local target_file=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --source) source_file="$2"; shift 2 ;;
      --target) target_file="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  if [[ -z "$source_file" ]]; then
    echo -e "${RED}Error: --source is required${NC}" >&2
    echo "Usage: settings-manager sync --source PATH --target PATH" >&2
    exit 1
  fi

  if [[ -z "$target_file" ]]; then
    echo -e "${RED}Error: --target is required${NC}" >&2
    echo "Usage: settings-manager sync --source PATH --target PATH" >&2
    exit 1
  fi

  if [[ ! -f "$source_file" ]]; then
    echo -e "${RED}Error: $source_file not found${NC}" >&2
    exit 1
  fi

  echo -e "${BLUE}Syncing settings...${NC}"

  local tmp_file="${target_file}.tmp.$$"
  mkdir -p "$(dirname "$target_file")"

  if ! strip_jsonc "$source_file" > "$tmp_file"; then
    echo -e "${RED}Error: Failed to parse JSONC${NC}" >&2
    rm -f "$tmp_file"
    exit 1
  fi

  mv "$tmp_file" "$target_file"
  echo -e "${GREEN}Synced: $source_file -> $target_file${NC}"
}

# Check if in sync
cmd_check() {
  local source_file=""
  local target_file=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --source) source_file="$2"; shift 2 ;;
      --target) target_file="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  if [[ -z "$source_file" ]] || [[ -z "$target_file" ]]; then
    echo -e "${RED}Error: --source and --target are required${NC}" >&2
    exit 1
  fi

  if [[ ! -f "$source_file" ]]; then
    echo -e "${YELLOW}Warning: $source_file not found${NC}" >&2
    exit 2
  fi

  if [[ ! -f "$target_file" ]]; then
    echo -e "${YELLOW}Warning: $target_file not found${NC}" >&2
    exit 2
  fi

  local expected
  if ! expected=$(strip_jsonc "$source_file"); then
    echo -e "${RED}Error: Failed to parse JSONC${NC}" >&2
    exit 1
  fi

  local actual
  actual=$(cat "$target_file")

  if [[ "$expected" == "$actual" ]]; then
    echo -e "${GREEN}In sync${NC}"
    exit 0
  else
    echo -e "${RED}Out of sync${NC}"
    echo ""
    echo "Diff (expected vs actual):"
    diff <(echo "$expected") <(echo "$actual") || true
    exit 1
  fi
}

# Validate against schema
cmd_validate() {
  local source_file=""
  local ai_explain="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --source) source_file="$2"; shift 2 ;;
      --ai-explain) ai_explain="true"; shift ;;
      *) shift ;;
    esac
  done

  # Enable AI explanation via env var
  if [[ "${SETTINGS_AI_EXPLAIN:-0}" == "1" ]]; then
    ai_explain="true"
  fi

  if [[ -z "$source_file" ]]; then
    echo -e "${RED}Error: --source is required${NC}" >&2
    exit 1
  fi

  if [[ ! -f "$source_file" ]]; then
    echo -e "${RED}Error: $source_file not found${NC}" >&2
    exit 1
  fi

  echo -e "${BLUE}Validating $source_file...${NC}"

  # Check JSONC syntax
  local parsed
  local jsonc_error=""
  if ! parsed=$(strip_jsonc "$source_file" 2>&1); then
    jsonc_error="$parsed"
    echo -e "${RED}JSONC syntax error${NC}" >&2
    echo "$jsonc_error" >&2

    # AI explanation for JSONC errors
    if [[ "$ai_explain" == "true" ]]; then
      explain_error "$source_file" "JSONC syntax error: $jsonc_error"
    fi
    exit 1
  fi

  echo -e "${GREEN}JSONC syntax: valid${NC}"

  mkdir -p "$CACHE_DIR"
  local schema_file="$CACHE_DIR/settings.schema.json"
  local cache_valid="false"

  if [[ -f "$schema_file" ]]; then
    local file_mtime
    if stat --version 2>/dev/null | grep -q GNU; then
      file_mtime=$(stat -c %Y "$schema_file")
    else
      file_mtime=$(stat -f %m "$schema_file")
    fi
    local now
    now=$(date +%s)
    local cache_age=$((now - file_mtime))
    if [[ $cache_age -lt $CACHE_TTL ]]; then
      cache_valid="true"
    fi
  fi

  if [[ "$cache_valid" != "true" ]]; then
    echo -e "${GRAY}Fetching schema from schemastore.org...${NC}"
    if curl -sL --max-time 10 "$SCHEMA_URL" -o "$schema_file.tmp" 2>/dev/null; then
      mv "$schema_file.tmp" "$schema_file"
    else
      echo -e "${YELLOW}Warning: Could not fetch schema${NC}"
      if [[ ! -f "$schema_file" ]]; then
        echo -e "${YELLOW}Schema validation skipped${NC}"
        exit 0
      fi
    fi
  fi

  local validation_output
  local validation_exit_code=0
  validation_output=$(node -e '
    const fs = require("fs");
    const schema = JSON.parse(fs.readFileSync(process.argv[1], "utf8"));
    const data = JSON.parse(process.argv[2]);

    const errors = [];

    if (data.permissions) {
      if (!Array.isArray(data.permissions.allow) && data.permissions.allow !== undefined) {
        errors.push("permissions.allow must be an array");
      }
      if (!Array.isArray(data.permissions.deny) && data.permissions.deny !== undefined) {
        errors.push("permissions.deny must be an array");
      }
    }

    if (data.hooks) {
      const validEvents = ["PreToolUse", "PostToolUse", "Notification", "Stop"];
      for (const event of Object.keys(data.hooks)) {
        if (!validEvents.includes(event)) {
          errors.push(`Unknown hook event: ${event}`);
        }
      }
    }

    if (errors.length > 0) {
      console.log("Validation errors:");
      errors.forEach(e => console.log("  - " + e));
      process.exit(1);
    }

    console.log("Schema validation: passed (basic checks)");
  ' "$schema_file" "$parsed" 2>&1) || validation_exit_code=$?

  echo "$validation_output"

  if [[ $validation_exit_code -ne 0 ]]; then
    if [[ "$ai_explain" == "true" ]]; then
      explain_error "$source_file" "$validation_output"
    fi
    exit 1
  fi
}

# AI-powered error explanation using headless Claude
explain_error() {
  local source_file="$1"
  local error_message="$2"

  if ! command -v claude &>/dev/null; then
    echo -e "${YELLOW}Note: Install Claude Code CLI for AI-powered error explanations${NC}" >&2
    return
  fi

  local file_content
  file_content=$(cat "$source_file")

  echo ""
  echo "┌─ AI Analysis ─────────────────────────────────────┐"

  claude -p "You are analyzing a Claude Code settings.json validation error.

Error message:
$error_message

File content (JSONC):
$file_content

Provide:
1. A clear explanation of what's wrong (2-3 sentences)
2. The exact fix needed (show the corrected line)
3. The line number if identifiable

Be concise and actionable." --model haiku 2>/dev/null | sed 's/^/│ /'

  echo "└───────────────────────────────────────────────────┘"
}

# Setup - flag-driven, no auto-detection
cmd_setup() {
  local source_path=""
  local target_path=""
  local hook_system=""
  local scripts_path=""
  local install_global="false"
  local dry_run="false"
  local force="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --source) source_path="$2"; shift 2 ;;
      --target) target_path="$2"; shift 2 ;;
      --hook-system) hook_system="$2"; shift 2 ;;
      --scripts-path) scripts_path="$2"; shift 2 ;;
      --install-global) install_global="true"; shift ;;
      --dry-run) dry_run="true"; shift ;;
      --force) force="true"; shift ;;
      --help|-h) cmd_setup_help; exit 0 ;;
      *) echo -e "${RED}Unknown option: $1${NC}" >&2; cmd_setup_help; exit 1 ;;
    esac
  done

  # Validate required flags
  if [[ -z "$source_path" ]]; then
    echo -e "${RED}Error: --source is required${NC}" >&2
    cmd_setup_help
    exit 1
  fi

  if [[ -z "$target_path" ]]; then
    echo -e "${RED}Error: --target is required${NC}" >&2
    cmd_setup_help
    exit 1
  fi

  if [[ -z "$hook_system" ]]; then
    echo -e "${RED}Error: --hook-system is required${NC}" >&2
    cmd_setup_help
    exit 1
  fi

  # Validate hook system
  case "$hook_system" in
    lefthook|husky|chezmoi|none) ;;
    *)
      echo -e "${RED}Error: Invalid hook system: $hook_system${NC}" >&2
      echo "Valid options: lefthook, husky, chezmoi, none" >&2
      exit 1
      ;;
  esac

  # Default scripts path based on hook system
  if [[ -z "$scripts_path" ]]; then
    case "$hook_system" in
      chezmoi) scripts_path="dot_local/bin" ;;
      *) scripts_path="scripts/claude" ;;
    esac
  fi

  echo -e "${BLUE}Setting up Claude Code JSONC settings...${NC}"
  echo ""
  echo "Configuration:"
  echo "  Source:      $source_path"
  echo "  Target:      $target_path"
  echo "  Hook system: $hook_system"
  echo "  Scripts:     $scripts_path"
  [[ "$install_global" == "true" ]] && echo "  Install:     ~/.local/bin/settings-manager"
  echo ""

  # Get directory containing source file
  local source_dir
  source_dir="$(dirname "$source_path")"

  # 1. Create source JSONC file
  if [[ -f "$source_path" && "$force" != "true" ]]; then
    echo -e "${YELLOW}Skipping: $source_path exists (use --force)${NC}"
  else
    if [[ "$dry_run" == "true" ]]; then
      echo -e "${GRAY}Would create: $source_path${NC}"
    else
      mkdir -p "$source_dir"

      local existing_content="{}"
      if [[ -f "$target_path" ]]; then
        existing_content=$(cat "$target_path")
        echo -e "${GREEN}Converting existing $target_path${NC}"
      fi

      # Determine header based on hook system
      local header
      if [[ "$hook_system" == "chezmoi" ]]; then
        header="// Claude Code Settings (JSONC - comments allowed)
//
// This file is managed by chezmoi. Edit this file, not the target.
// Run 'chezmoi apply' to sync changes.
//
// Schema: https://json.schemastore.org/claude-code-settings.json
"
      else
        header="// Claude Code Settings (JSONC - comments allowed)
//
// This file is the source of truth. Edit this file, not settings.json.
// Changes sync automatically on commit.
//
// Schema: https://json.schemastore.org/claude-code-settings.json
"
      fi

      echo "$header" > "$source_path"

      node -e '
        const input = process.argv[1];
        try {
          const obj = JSON.parse(input);
          obj["$schema"] = "https://json.schemastore.org/claude-code-settings.json";
          const ordered = { "$schema": obj["$schema"] };
          for (const key of Object.keys(obj)) {
            if (key !== "$schema") ordered[key] = obj[key];
          }
          console.log(JSON.stringify(ordered, null, 2));
        } catch {
          console.log("{}");
        }
      ' "$existing_content" >> "$source_path"

      echo -e "${GREEN}Created: $source_path${NC}"
    fi
  fi

  # 2. Setup based on hook system
  case "$hook_system" in
    chezmoi)
      setup_chezmoi "$source_path" "$target_path" "$scripts_path" "$dry_run" "$force"
      ;;
    lefthook)
      setup_git_hooks "$source_path" "$target_path" "$scripts_path" "lefthook" "$dry_run" "$force"
      ;;
    husky)
      setup_git_hooks "$source_path" "$target_path" "$scripts_path" "husky" "$dry_run" "$force"
      ;;
    none)
      echo -e "${GRAY}Skipping hook setup (--hook-system none)${NC}"
      ;;
  esac

  # 3. Install globally if requested
  if [[ "$install_global" == "true" ]]; then
    install_to_path "$dry_run"
  fi

  echo ""
  echo -e "${GREEN}Setup complete!${NC}"
  echo ""

  case "$hook_system" in
    chezmoi)
      echo "Next steps:"
      echo "  1. Edit $source_path"
      echo "  2. Run 'chezmoi apply' to sync"
      echo "  3. Commit your changes"
      ;;
    lefthook|husky)
      echo "Next steps:"
      echo "  1. Edit $source_path"
      echo "  2. Commit - the hook will sync automatically"
      echo "  3. Run 'settings-manager sync' to sync manually"
      ;;
    none)
      echo "Next steps:"
      echo "  1. Edit $source_path"
      echo "  2. Run 'settings-manager sync --source $source_path --target $target_path' to sync"
      ;;
  esac
}

cmd_setup_help() {
  cat << 'EOF'
Usage: settings-manager setup [options]

Required flags:
  --source PATH       Path to create __settings.jsonc
  --target PATH       Path where settings.json lives/will be generated
  --hook-system TYPE  Hook system: lefthook | husky | chezmoi | none

Optional flags:
  --scripts-path PATH Where to put helper scripts (default: scripts/claude)
  --install-global    Install settings-manager to ~/.local/bin
  --dry-run           Preview changes without applying
  --force             Overwrite existing files

Examples:
  # Regular project with lefthook
  settings-manager setup \
    --source .claude/__settings.jsonc \
    --target .claude/settings.json \
    --hook-system lefthook

  # Chezmoi dotfiles (global settings)
  settings-manager setup \
    --source dot_claude/__settings.jsonc \
    --target dot_claude/settings.json \
    --hook-system chezmoi \
    --install-global

  # Stow dotfiles
  settings-manager setup \
    --source claude/__settings.jsonc \
    --target claude/settings.json \
    --hook-system lefthook \
    --scripts-path claude/scripts
EOF
}

# Setup for git hooks (lefthook or husky)
setup_git_hooks() {
  local source_path="$1"
  local target_path="$2"
  local scripts_path="$3"
  local hook_type="$4"
  local dry_run="$5"
  local force="$6"

  # Create sync script
  local sync_script="$scripts_path/settings-sync.sh"
  mkdir -p "$scripts_path"

  if [[ -f "$sync_script" && "$force" != "true" ]]; then
    echo -e "${YELLOW}Skipping: $sync_script exists${NC}"
  else
    if [[ "$dry_run" == "true" ]]; then
      echo -e "${GRAY}Would create: $sync_script${NC}"
    else
      cat > "$sync_script" << SCRIPT
#!/usr/bin/env bash
# Sync $source_path to $target_path
set -euo pipefail

REPO_ROOT="\$(git rev-parse --show-toplevel)"
cd "\$REPO_ROOT"

SOURCE="$source_path"
TARGET="$target_path"

if [[ ! -f "\$SOURCE" ]]; then
  echo "Error: \$SOURCE not found" >&2
  exit 1
fi

# Validate before sync (with AI explanation on error)
export SETTINGS_AI_EXPLAIN=1
if command -v settings-manager &>/dev/null; then
  if ! settings-manager validate --source "\$SOURCE"; then
    echo "Fix the validation errors above, then commit again."
    exit 1
  fi
fi

node -e '
  const fs = require("fs");
  const input = fs.readFileSync(process.argv[1], "utf8");
  let result = "", inString = false, i = 0;
  while (i < input.length) {
    if (!inString && input[i] === "\"") {
      inString = true; result += input[i]; i++; continue;
    }
    if (inString) {
      if (input[i] === "\\\\" && i + 1 < input.length) { result += input[i] + input[i+1]; i += 2; continue; }
      if (input[i] === "\"") inString = false;
      result += input[i]; i++; continue;
    }
    if (input[i] === "/" && i + 1 < input.length) {
      if (input[i+1] === "/") { while (i < input.length && input[i] !== "\\n") i++; continue; }
      if (input[i+1] === "*") { i += 2; while (i+1 < input.length && !(input[i] === "*" && input[i+1] === "/")) i++; i += 2; continue; }
    }
    result += input[i]; i++;
  }
  const obj = JSON.parse(result);
  console.log(JSON.stringify(obj, null, 2));
' "\$SOURCE" > "\${TARGET}.tmp"

mv "\${TARGET}.tmp" "\$TARGET"
echo "Synced: \$SOURCE -> \$TARGET"
SCRIPT
      chmod +x "$sync_script"
      echo -e "${GREEN}Created: $sync_script${NC}"
    fi
  fi

  # Create block script
  local block_script
  block_script="$(dirname "$scripts_path")/git/block-settings-json.sh"
  mkdir -p "$(dirname "$block_script")"

  if [[ -f "$block_script" && "$force" != "true" ]]; then
    echo -e "${YELLOW}Skipping: $block_script exists${NC}"
  else
    if [[ "$dry_run" == "true" ]]; then
      echo -e "${GRAY}Would create: $block_script${NC}"
    else
      local target_pattern
      target_pattern=$(echo "$target_path" | sed 's/\./\\./g' | sed 's/\//\\\//g')
      local source_pattern
      source_pattern=$(echo "$source_path" | sed 's/\./\\./g' | sed 's/\//\\\//g')

      cat > "$block_script" << SCRIPT
#!/usr/bin/env bash
set -euo pipefail

if [[ "\${SETTINGS_BYPASS:-}" == "1" ]]; then
  exit 0
fi

REPO_ROOT="\$(git rev-parse --show-toplevel)"
cd "\$REPO_ROOT"

if git diff --cached --name-only | grep -q "^${target_pattern}\$"; then
  if git diff --cached --name-only | grep -q "^${source_pattern}\$"; then
    exit 0
  fi

  echo ""
  echo "ERROR: Direct edits to $target_path are blocked."
  echo ""
  echo "Edit $source_path instead (supports comments)."
  echo ""
  echo "Bypass (emergency only):"
  echo "  SETTINGS_BYPASS=1 git commit -m \"...\""
  echo ""
  exit 1
fi
SCRIPT
      chmod +x "$block_script"
      echo -e "${GREEN}Created: $block_script${NC}"
    fi
  fi

  # Setup hook configuration
  if [[ "$hook_type" == "lefthook" ]]; then
    setup_lefthook_config "$source_path" "$sync_script" "$block_script" "$dry_run" "$force"
  else
    setup_husky_config "$source_path" "$sync_script" "$block_script" "$dry_run" "$force"
  fi

  # Update .gitattributes
  if [[ "$dry_run" == "true" ]]; then
    echo -e "${GRAY}Would update: .gitattributes${NC}"
  else
    if ! grep -q "$target_path.*linguist-generated" .gitattributes 2>/dev/null; then
      echo "$target_path linguist-generated=true" >> .gitattributes
      echo -e "${GREEN}Updated: .gitattributes${NC}"
    fi
  fi
}

setup_lefthook_config() {
  local source_path="$1"
  local sync_script="$2"
  local block_script="$3"
  local dry_run="$4"
  local force="$5"

  local lefthook_file="lefthook.yml"
  [[ -f "lefthook.yaml" ]] && lefthook_file="lefthook.yaml"

  if [[ "$dry_run" == "true" ]]; then
    echo -e "${GRAY}Would update: $lefthook_file${NC}"
    return
  fi

  local source_pattern
  source_pattern=$(echo "$source_path" | sed 's/\./\\\\./g')

  if [[ ! -f "$lefthook_file" ]]; then
    cat > "$lefthook_file" << YAML
pre-commit:
  jobs:
    - name: block-settings-json
      priority: 0
      run: ./$block_script
    - name: sync-settings
      priority: 1
      run: |
        if git diff --cached --name-only | grep -q "^${source_pattern}\$"; then
          ./$sync_script
          git add $target_path
        fi
YAML
    echo -e "${GREEN}Created: $lefthook_file${NC}"
    # Auto-install lefthook hooks
    if command -v lefthook &>/dev/null; then
      echo -e "${BLUE}Installing lefthook hooks...${NC}"
      lefthook install
    else
      echo -e "${YELLOW}Note: Run 'lefthook install' to activate hooks${NC}"
    fi
  else
    if grep -q "block-settings-json\|sync-settings" "$lefthook_file" 2>/dev/null; then
      if [[ "$force" != "true" ]]; then
        echo -e "${YELLOW}Skipping: hooks already in $lefthook_file (use --force)${NC}"
        return
      fi
    fi

    echo -e "${YELLOW}Manual step: Add to $lefthook_file:${NC}"
    cat << YAML
pre-commit:
  jobs:
    - name: block-settings-json
      priority: 0
      run: ./$block_script
    - name: sync-settings
      priority: 1
      run: |
        if git diff --cached --name-only | grep -q "^${source_pattern}\$"; then
          ./$sync_script
          git add $target_path
        fi
YAML
  fi
}

setup_husky_config() {
  local source_path="$1"
  local sync_script="$2"
  local block_script="$3"
  local dry_run="$4"
  local force="$5"

  if [[ "$dry_run" == "true" ]]; then
    echo -e "${GRAY}Would update: .husky/pre-commit${NC}"
    return
  fi

  mkdir -p .husky

  local pre_commit=".husky/pre-commit"
  local source_pattern
  source_pattern=$(echo "$source_path" | sed 's/\./\\\\./g')

  if [[ ! -f "$pre_commit" ]]; then
    cat > "$pre_commit" << BASH
#!/usr/bin/env bash

./$block_script

if git diff --cached --name-only | grep -q "^${source_pattern}\$"; then
  ./$sync_script
  git add $target_path
fi
BASH
    chmod +x "$pre_commit"
    echo -e "${GREEN}Created: $pre_commit${NC}"
    # Auto-install husky hooks
    if command -v npx &>/dev/null; then
      echo -e "${BLUE}Installing husky hooks...${NC}"
      npx husky install 2>/dev/null || npx husky init 2>/dev/null || true
    else
      echo -e "${YELLOW}Note: Run 'npx husky install' to activate hooks${NC}"
    fi
  else
    if grep -q "block-settings-json\|settings-sync" "$pre_commit" 2>/dev/null; then
      if [[ "$force" != "true" ]]; then
        echo -e "${YELLOW}Skipping: hooks already in $pre_commit (use --force)${NC}"
        return
      fi
    fi

    echo -e "${YELLOW}Manual step: Add to .husky/pre-commit:${NC}"
    cat << BASH
./$block_script

if git diff --cached --name-only | grep -q "^${source_pattern}\$"; then
  ./$sync_script
  git add $target_path
fi
BASH
  fi
}

# Setup for chezmoi
setup_chezmoi() {
  local source_path="$1"
  local target_path="$2"
  local scripts_path="$3"
  local dry_run="$4"
  local force="$5"

  # Create run_onchange_ script
  local run_script="run_onchange_after_claude-settings.sh.tmpl"

  if [[ -f "$run_script" && "$force" != "true" ]]; then
    echo -e "${YELLOW}Skipping: $run_script exists${NC}"
  else
    if [[ "$dry_run" == "true" ]]; then
      echo -e "${GRAY}Would create: $run_script${NC}"
    else
      # Determine the chezmoi include path (source_path without leading ./)
      local include_path="${source_path#./}"

      cat > "$run_script" << TMPL
#!/bin/bash
# Sync Claude Code JSONC settings to JSON
# Triggered when content changes
# hash: {{ include "$include_path" | sha256sum }}

set -euo pipefail

# Resolve target path (chezmoi transforms dot_ to .)
TARGET_DIR="\$HOME/.claude"
SOURCE="\$TARGET_DIR/__settings.jsonc"
TARGET="\$TARGET_DIR/settings.json"

if [[ ! -f "\$SOURCE" ]]; then
  echo "Claude settings source not found: \$SOURCE"
  exit 0
fi

echo "Syncing Claude settings..."

# Validate before sync (with AI explanation on error)
export SETTINGS_AI_EXPLAIN=1
if command -v settings-manager &>/dev/null; then
  if ! settings-manager validate --source "\$SOURCE"; then
    echo "Fix the validation errors above, then run: chezmoi apply"
    exit 1
  fi
fi

node -e '
  const fs = require("fs");
  const input = fs.readFileSync(process.argv[1], "utf8");
  let result = "", inString = false, i = 0;
  while (i < input.length) {
    if (!inString && input[i] === "\"") {
      inString = true; result += input[i]; i++; continue;
    }
    if (inString) {
      if (input[i] === "\\\\" && i + 1 < input.length) { result += input[i] + input[i+1]; i += 2; continue; }
      if (input[i] === "\"") inString = false;
      result += input[i]; i++; continue;
    }
    if (input[i] === "/" && i + 1 < input.length) {
      if (input[i+1] === "/") { while (i < input.length && input[i] !== "\\n") i++; continue; }
      if (input[i+1] === "*") { i += 2; while (i+1 < input.length && !(input[i] === "*" && input[i+1] === "/")) i++; i += 2; continue; }
    }
    result += input[i]; i++;
  }
  const obj = JSON.parse(result);
  console.log(JSON.stringify(obj, null, 2));
' "\$SOURCE" > "\${TARGET}.tmp"

mv "\${TARGET}.tmp" "\$TARGET"
echo "Synced: \$SOURCE -> \$TARGET"
TMPL
      chmod +x "$run_script"
      echo -e "${GREEN}Created: $run_script${NC}"
    fi
  fi

  # Update .chezmoiignore
  local target_dir
  target_dir="$(dirname "$target_path")"
  local ignore_pattern="$target_dir/settings.json"

  if [[ "$dry_run" == "true" ]]; then
    echo -e "${GRAY}Would update: .chezmoiignore${NC}"
  else
    if ! grep -q "$ignore_pattern" .chezmoiignore 2>/dev/null; then
      echo "$ignore_pattern" >> .chezmoiignore
      echo -e "${GREEN}Updated: .chezmoiignore${NC}"
    fi
  fi
}

# Install settings-manager to ~/.local/bin
install_to_path() {
  local dry_run="$1"
  local install_dir="$HOME/.local/bin"
  local install_path="$install_dir/settings-manager"

  if [[ "$dry_run" == "true" ]]; then
    echo -e "${GRAY}Would install: $install_path${NC}"
    return
  fi

  mkdir -p "$install_dir"
  cp "$SCRIPT_PATH" "$install_path"
  chmod +x "$install_path"
  echo -e "${GREEN}Installed: $install_path${NC}"

  if [[ ":$PATH:" != *":$install_dir:"* ]]; then
    echo -e "${YELLOW}Note: Add $install_dir to PATH if not already present${NC}"
  fi
}

# ================================================================
# Router
# ================================================================
COMMAND="${1:-help}"
shift || true

case "$COMMAND" in
  setup) cmd_setup "$@" ;;
  sync) cmd_sync "$@" ;;
  check) cmd_check "$@" ;;
  validate) cmd_validate "$@" ;;
  help|--help|-h)
    echo "Usage: settings-manager <command> [options]"
    echo ""
    echo "Commands:"
    echo "  setup      Set up JSONC settings workflow (run 'setup --help' for details)"
    echo "  sync       Sync JSONC to JSON"
    echo "  check      Check if files are in sync"
    echo "  validate   Validate JSONC against schema"
    echo ""
    echo "Examples:"
    echo "  settings-manager setup --source .claude/__settings.jsonc --target .claude/settings.json --hook-system lefthook"
    echo "  settings-manager sync --source .claude/__settings.jsonc --target .claude/settings.json"
    echo "  settings-manager check --source .claude/__settings.jsonc --target .claude/settings.json"
    echo "  settings-manager validate --source .claude/__settings.jsonc"
    ;;
  *)
    echo "Error: Unknown command: $COMMAND" >&2
    echo "Run 'settings-manager help' for usage" >&2
    exit 1
    ;;
esac
