#!/usr/bin/env bash
set -euo pipefail

# ================================================================
# settings-manager - Claude Code JSONC settings management
# ================================================================
# Flag-driven script for setting up and managing JSONC settings.
# Claude handles decision-making; this script handles execution.
# ================================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
NC='\033[0m'

# Configuration
SCHEMA_URL="https://json.schemastore.org/claude-code-settings.json"
CACHE_DIR="${HOME}/.cache/claude-settings-manager"
CACHE_TTL=86400  # 24 hours

# Script location (for --install-global)
SCRIPT_PATH="${BASH_SOURCE[0]}"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# ================================================================
# JSONC Parser (inline node - strips comments)
# ================================================================
strip_jsonc() {
  node -e '
    const fs = require("fs");
    const input = fs.readFileSync(process.argv[1], "utf8");

    let result = "";
    let inString = false;
    let stringChar = "";
    let i = 0;

    while (i < input.length) {
      if (!inString && input[i] === "\"") {
        inString = true;
        stringChar = input[i];
        result += input[i];
        i++;
        continue;
      }

      if (inString) {
        if (input[i] === "\\" && i + 1 < input.length) {
          result += input[i] + input[i + 1];
          i += 2;
          continue;
        }
        if (input[i] === stringChar) {
          inString = false;
        }
        result += input[i];
        i++;
        continue;
      }

      if (input[i] === "/" && i + 1 < input.length) {
        if (input[i + 1] === "/") {
          while (i < input.length && input[i] !== "\n") i++;
          continue;
        }
        if (input[i + 1] === "*") {
          i += 2;
          while (i + 1 < input.length && !(input[i] === "*" && input[i + 1] === "/")) i++;
          i += 2;
          continue;
        }
      }

      result += input[i];
      i++;
    }

    try {
      const obj = JSON.parse(result);
      console.log(JSON.stringify(obj, null, 2));
    } catch (e) {
      console.error("JSONC parse error:", e.message);
      process.exit(1);
    }
  ' "$1"
}

# ================================================================
# Commands
# ================================================================

# Sync JSONC to JSON
cmd_sync() {
  local source_file=""
  local target_file=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --source) source_file="$2"; shift 2 ;;
      --target) target_file="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  if [[ -z "$source_file" ]]; then
    echo -e "${RED}Error: --source is required${NC}" >&2
    echo "Usage: settings-manager sync --source PATH --target PATH" >&2
    exit 1
  fi

  if [[ -z "$target_file" ]]; then
    echo -e "${RED}Error: --target is required${NC}" >&2
    echo "Usage: settings-manager sync --source PATH --target PATH" >&2
    exit 1
  fi

  if [[ ! -f "$source_file" ]]; then
    echo -e "${RED}Error: $source_file not found${NC}" >&2
    exit 1
  fi

  echo -e "${BLUE}Syncing settings...${NC}"

  local tmp_file="${target_file}.tmp.$$"
  mkdir -p "$(dirname "$target_file")"

  if ! strip_jsonc "$source_file" > "$tmp_file"; then
    echo -e "${RED}Error: Failed to parse JSONC${NC}" >&2
    rm -f "$tmp_file"
    exit 1
  fi

  mv "$tmp_file" "$target_file"
  echo -e "${GREEN}Synced: $source_file -> $target_file${NC}"
}

# Check if in sync
cmd_check() {
  local source_file=""
  local target_file=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --source) source_file="$2"; shift 2 ;;
      --target) target_file="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  if [[ -z "$source_file" ]] || [[ -z "$target_file" ]]; then
    echo -e "${RED}Error: --source and --target are required${NC}" >&2
    exit 1
  fi

  if [[ ! -f "$source_file" ]]; then
    echo -e "${YELLOW}Warning: $source_file not found${NC}" >&2
    exit 2
  fi

  if [[ ! -f "$target_file" ]]; then
    echo -e "${YELLOW}Warning: $target_file not found${NC}" >&2
    exit 2
  fi

  local expected
  if ! expected=$(strip_jsonc "$source_file"); then
    echo -e "${RED}Error: Failed to parse JSONC${NC}" >&2
    exit 1
  fi

  local actual
  actual=$(cat "$target_file")

  if [[ "$expected" == "$actual" ]]; then
    echo -e "${GREEN}In sync${NC}"
    exit 0
  else
    echo -e "${RED}Out of sync${NC}"
    echo ""
    echo "Diff (expected vs actual):"
    diff <(echo "$expected") <(echo "$actual") || true
    exit 1
  fi
}

# Validate against schema
cmd_validate() {
  local source_file=""
  local ai_explain="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --source) source_file="$2"; shift 2 ;;
      --ai-explain) ai_explain="true"; shift ;;
      *) shift ;;
    esac
  done

  # Enable AI explanation via env var
  if [[ "${SETTINGS_AI_EXPLAIN:-0}" == "1" ]]; then
    ai_explain="true"
  fi

  if [[ -z "$source_file" ]]; then
    echo -e "${RED}Error: --source is required${NC}" >&2
    exit 1
  fi

  if [[ ! -f "$source_file" ]]; then
    echo -e "${RED}Error: $source_file not found${NC}" >&2
    exit 1
  fi

  echo -e "${BLUE}Validating $source_file...${NC}"

  # Check JSONC syntax
  local parsed
  local jsonc_error=""
  if ! parsed=$(strip_jsonc "$source_file" 2>&1); then
    jsonc_error="$parsed"
    echo -e "${RED}JSONC syntax error${NC}" >&2
    echo "$jsonc_error" >&2

    # AI explanation for JSONC errors
    if [[ "$ai_explain" == "true" ]]; then
      explain_error "$source_file" "JSONC syntax error: $jsonc_error"
    fi
    exit 1
  fi

  echo -e "${GREEN}JSONC syntax: valid${NC}"

  mkdir -p "$CACHE_DIR"
  local schema_file="$CACHE_DIR/settings.schema.json"
  local cache_valid="false"

  if [[ -f "$schema_file" ]]; then
    local file_mtime
    if stat --version 2>/dev/null | grep -q GNU; then
      file_mtime=$(stat -c %Y "$schema_file")
    else
      file_mtime=$(stat -f %m "$schema_file")
    fi
    local now
    now=$(date +%s)
    local cache_age=$((now - file_mtime))
    if [[ $cache_age -lt $CACHE_TTL ]]; then
      cache_valid="true"
    fi
  fi

  if [[ "$cache_valid" != "true" ]]; then
    echo -e "${GRAY}Fetching schema from schemastore.org...${NC}"
    if curl -sL --max-time 10 "$SCHEMA_URL" -o "$schema_file.tmp" 2>/dev/null; then
      mv "$schema_file.tmp" "$schema_file"
    else
      echo -e "${YELLOW}Warning: Could not fetch schema${NC}"
      if [[ ! -f "$schema_file" ]]; then
        echo -e "${YELLOW}Schema validation skipped${NC}"
        exit 0
      fi
    fi
  fi

  local validation_output
  local validation_exit_code=0
  validation_output=$(node -e '
    const fs = require("fs");
    const schema = JSON.parse(fs.readFileSync(process.argv[1], "utf8"));
    const data = JSON.parse(process.argv[2]);

    const errors = [];

    if (data.permissions) {
      if (!Array.isArray(data.permissions.allow) && data.permissions.allow !== undefined) {
        errors.push("permissions.allow must be an array");
      }
      if (!Array.isArray(data.permissions.deny) && data.permissions.deny !== undefined) {
        errors.push("permissions.deny must be an array");
      }
    }

    if (data.hooks) {
      const validEvents = ["PreToolUse", "PostToolUse", "Notification", "Stop"];
      for (const event of Object.keys(data.hooks)) {
        if (!validEvents.includes(event)) {
          errors.push(`Unknown hook event: ${event}`);
        }
      }
    }

    if (errors.length > 0) {
      console.log("Validation errors:");
      errors.forEach(e => console.log("  - " + e));
      process.exit(1);
    }

    console.log("Schema validation: passed (basic checks)");
  ' "$schema_file" "$parsed" 2>&1) || validation_exit_code=$?

  echo "$validation_output"

  if [[ $validation_exit_code -ne 0 ]]; then
    if [[ "$ai_explain" == "true" ]]; then
      explain_error "$source_file" "$validation_output"
    fi
    exit 1
  fi
}

# AI-powered error explanation using headless Claude
explain_error() {
  local source_file="$1"
  local error_message="$2"

  if ! command -v claude &>/dev/null; then
    echo -e "${YELLOW}Note: Install Claude Code CLI for AI-powered error explanations${NC}" >&2
    return
  fi

  local file_content
  file_content=$(cat "$source_file")

  echo ""
  echo "┌─ AI Analysis ─────────────────────────────────────┐"

  claude -p "You are analyzing a Claude Code settings.json validation error.

Error message:
$error_message

File content (JSONC):
$file_content

Provide:
1. A clear explanation of what's wrong (2-3 sentences)
2. The exact fix needed (show the corrected line)
3. The line number if identifiable

Be concise and actionable." --model haiku 2>/dev/null | sed 's/^/│ /'

  echo "└───────────────────────────────────────────────────┘"
}

# ================================================================
# Schema Extraction Commands
# ================================================================

# Extract schema from Claude Code npm package
cmd_schema_extract() {
  local version="latest"
  local output_dir="."
  local format="both"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --version) version="$2"; shift 2 ;;
      --output-dir) output_dir="$2"; shift 2 ;;
      --format) format="$2"; shift 2 ;;
      --help|-h) cmd_schema_extract_help; exit 0 ;;
      *) echo -e "${RED}Unknown option: $1${NC}" >&2; cmd_schema_extract_help; exit 1 ;;
    esac
  done

  # Validate format
  case "$format" in
    json|md|both) ;;
    *) echo -e "${RED}Invalid format: $format (use json, md, or both)${NC}" >&2; exit 1 ;;
  esac

  mkdir -p "$output_dir"
  mkdir -p "$CACHE_DIR"

  echo -e "${BLUE}Extracting Claude Code schema...${NC}"

  # Resolve version if "latest"
  if [[ "$version" == "latest" ]]; then
    echo -e "${GRAY}Fetching latest version...${NC}"
    version=$(curl -sL "https://registry.npmjs.org/@anthropic-ai/claude-code/latest" | node -p "JSON.parse(require('fs').readFileSync(0,'utf8')).version" 2>/dev/null)
    if [[ -z "$version" ]]; then
      echo -e "${RED}Error: Could not fetch latest version${NC}" >&2
      exit 1
    fi
  fi

  echo -e "${CYAN}Version: $version${NC}"

  # Check cache
  local cache_file="$CACHE_DIR/describe-strings-$version.json"
  local cli_cache="$CACHE_DIR/cli-$version.js"

  if [[ -f "$cache_file" ]]; then
    local file_mtime
    if stat --version 2>/dev/null | grep -q GNU; then
      file_mtime=$(stat -c %Y "$cache_file")
    else
      file_mtime=$(stat -f %m "$cache_file")
    fi
    local now
    now=$(date +%s)
    local cache_age=$((now - file_mtime))
    if [[ $cache_age -lt $CACHE_TTL ]]; then
      echo -e "${GRAY}Using cached extraction...${NC}"
      generate_schema_outputs "$cache_file" "$version" "$output_dir" "$format"
      return
    fi
  fi

  # Download and extract cli.js
  echo -e "${GRAY}Downloading npm package...${NC}"
  local tarball_url="https://registry.npmjs.org/@anthropic-ai/claude-code/-/claude-code-$version.tgz"

  if ! curl -sL "$tarball_url" | tar -xzf - -O package/cli.js > "$cli_cache" 2>/dev/null; then
    echo -e "${RED}Error: Failed to download package${NC}" >&2
    exit 1
  fi

  if [[ ! -s "$cli_cache" ]]; then
    echo -e "${RED}Error: cli.js is empty${NC}" >&2
    exit 1
  fi

  echo -e "${GREEN}Downloaded: $(wc -c < "$cli_cache" | xargs) bytes${NC}"

  # Extract describe strings using external script
  echo -e "${GRAY}Extracting .describe() strings...${NC}"
  extract_describe_strings "$cli_cache" "$version" > "$cache_file"

  if [[ ! -s "$cache_file" ]]; then
    echo -e "${RED}Error: Extraction failed${NC}" >&2
    exit 1
  fi

  local count
  count=$(node -p "JSON.parse(require('fs').readFileSync('$cache_file','utf8')).totalDescribeStrings")
  echo -e "${GREEN}Extracted: $count describe strings${NC}"

  generate_schema_outputs "$cache_file" "$version" "$output_dir" "$format"
}

# Helper: Extract describe strings from cli.js bundle
extract_describe_strings() {
  local cli_file="$1"
  local version="$2"

  node --input-type=module -e "
import { readFileSync } from 'fs';
const content = readFileSync('$cli_file', 'utf8');

// Extract all .describe('...') strings
const describeRegex = /\\.describe\\(['\"]([^'\"]+)['\"]\\)/g;
const descriptions = new Set();
let match;
while ((match = describeRegex.exec(content)) !== null) {
  descriptions.add(match[1]);
}

// Try to extract property names with their descriptions
// Pattern: 'propertyName':S.type().describe('...')
const propRegex = /['\"]([a-zA-Z_][a-zA-Z0-9_]*)['\"]\s*:\s*[A-Z]\.[a-z]+\\([^)]*\\)(?:\\.[a-z]+\\([^)]*\\))*\\.describe\\(['\"]([^'\"]+)['\"]\\)/g;
const properties = {};
while ((match = propRegex.exec(content)) !== null) {
  properties[match[1]] = match[2];
}

const result = {
  version: '$version',
  extractedAt: new Date().toISOString(),
  totalDescribeStrings: descriptions.size,
  propertyMappings: Object.keys(properties).length,
  descriptions: Array.from(descriptions).sort(),
  properties: properties
};

console.log(JSON.stringify(result, null, 2));
"
}

# Generate JSON Schema and/or Markdown from extraction
generate_schema_outputs() {
  local cache_file="$1"
  local version="$2"
  local output_dir="$3"
  local format="$4"

  # Generate JSON Schema
  if [[ "$format" == "json" || "$format" == "both" ]]; then
    local schema_file="$output_dir/claude-code-$version.schema.json"
    echo -e "${GRAY}Generating JSON Schema...${NC}"
    generate_json_schema "$cache_file" > "$schema_file"
    echo -e "${GREEN}Created: $schema_file${NC}"
  fi

  # Generate Markdown documentation
  if [[ "$format" == "md" || "$format" == "both" ]]; then
    local md_file="$output_dir/claude-code-$version-reference.md"
    echo -e "${GRAY}Generating Markdown documentation...${NC}"
    generate_markdown_docs "$cache_file" > "$md_file"
    echo -e "${GREEN}Created: $md_file${NC}"
  fi

  # Copy raw extraction for debugging (skip if same file)
  local raw_file="$output_dir/describe-strings-$version.json"
  if [[ "$cache_file" != "$raw_file" ]]; then
    cp "$cache_file" "$raw_file"
    echo -e "${GREEN}Created: $raw_file${NC}"
  fi
}

# Helper: Generate JSON Schema from extracted data
generate_json_schema() {
  local cache_file="$1"
  node --input-type=module -e "
import { readFileSync } from 'fs';
const data = JSON.parse(readFileSync('$cache_file', 'utf8'));

const schema = {
  '\$schema': 'http://json-schema.org/draft-07/schema#',
  '\$id': 'claude-code-extracted-' + data.version,
  title: 'Claude Code Extracted Schema',
  description: 'Schema extracted from Claude Code v' + data.version + ' bundle. Auto-generated.',
  type: 'object',
  properties: {}
};

// Add known property mappings to schema
for (const [prop, desc] of Object.entries(data.properties)) {
  schema.properties[prop] = { description: desc };
}

// Categorize descriptions
const categories = { settings: 0, tools: 0, internal: 0 };
for (const desc of data.descriptions) {
  const lower = desc.toLowerCase();
  if (lower.includes('permission') || lower.includes('hook') || lower.includes('model')) {
    categories.settings++;
  } else if (lower.includes('tool') || lower.includes('command') || lower.includes('file_path')) {
    categories.tools++;
  } else {
    categories.internal++;
  }
}

schema['x-extracted'] = {
  version: data.version,
  extractedAt: data.extractedAt,
  totalDescribeStrings: data.totalDescribeStrings,
  propertyMappings: data.propertyMappings,
  categories,
  descriptions: data.descriptions
};

console.log(JSON.stringify(schema, null, 2));
"
}

# Helper: Generate Markdown documentation
generate_markdown_docs() {
  local cache_file="$1"
  node --input-type=module -e "
import { readFileSync } from 'fs';
const data = JSON.parse(readFileSync('$cache_file', 'utf8'));

let md = \`# Claude Code Schema Reference

Extracted from Claude Code v\${data.version}
Generated: \${data.extractedAt}

## Summary

- **Total describe strings:** \${data.totalDescribeStrings}
- **Property mappings found:** \${data.propertyMappings}

## Extracted Property Mappings

| Property | Description |
|----------|-------------|
\`;

const sortedProps = Object.entries(data.properties).sort(([a], [b]) => a.localeCompare(b));
for (const [prop, desc] of sortedProps) {
  md += \`| \\\`\${prop}\\\` | \${desc.replace(/\\|/g, '\\\\|')} |\\n\`;
}

// Categorize descriptions
const categories = {
  'Settings': [],
  'Tool Schemas': [],
  'Internal': []
};

for (const desc of data.descriptions) {
  const lower = desc.toLowerCase();
  if (lower.includes('permission') || lower.includes('hook') || lower.includes('model') ||
      lower.includes('setting') || lower.includes('api key') || lower.includes('environment')) {
    categories['Settings'].push(desc);
  } else if (lower.includes('tool') || lower.includes('bash') || lower.includes('edit') ||
             lower.includes('command') || lower.includes('file_path') || lower.includes('pattern')) {
    categories['Tool Schemas'].push(desc);
  } else {
    categories['Internal'].push(desc);
  }
}

md += \`\\n## All Describe Strings by Category\\n\`;

for (const [category, descs] of Object.entries(categories)) {
  if (descs.length === 0) continue;
  md += \`\\n### \${category} (\${descs.length})\\n\\n\`;
  for (const d of descs.sort()) {
    md += \`- \${d}\\n\`;
  }
}

console.log(md);
"
}

cmd_schema_extract_help() {
  cat << 'EOF'
Usage: settings-manager schema-extract [options]

Extract Zod schema definitions from Claude Code npm package.

Options:
  --version VERSION    Version to extract (default: latest)
  --output-dir PATH    Output directory (default: current dir)
  --format FORMAT      Output format: json, md, or both (default: both)

Examples:
  # Extract latest version
  settings-manager schema-extract

  # Extract specific version
  settings-manager schema-extract --version 2.0.62

  # Output only Markdown
  settings-manager schema-extract --format md --output-dir docs/

Output files:
  - claude-code-{VERSION}.schema.json    JSON Schema (partial)
  - claude-code-{VERSION}-reference.md   Markdown documentation
  - describe-strings-{VERSION}.json      Raw extracted data
EOF
}

# Compare schemas between versions or against schemastore
cmd_schema_diff() {
  local base="schemastore"
  local compare="latest"
  local output_format="text"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --base) base="$2"; shift 2 ;;
      --compare) compare="$2"; shift 2 ;;
      --json) output_format="json"; shift ;;
      --help|-h) cmd_schema_diff_help; exit 0 ;;
      *) echo -e "${RED}Unknown option: $1${NC}" >&2; cmd_schema_diff_help; exit 1 ;;
    esac
  done

  echo -e "${BLUE}Comparing schemas...${NC}"
  echo -e "  Base:    $base"
  echo -e "  Compare: $compare"
  echo ""

  mkdir -p "$CACHE_DIR"

  # Get base schema
  local base_file
  if [[ "$base" == "schemastore" ]]; then
    base_file="$CACHE_DIR/schemastore-settings.json"
    echo -e "${GRAY}Fetching schemastore.org schema...${NC}"
    if ! curl -sL "$SCHEMA_URL" -o "$base_file" 2>/dev/null; then
      echo -e "${RED}Error: Could not fetch schemastore schema${NC}" >&2
      exit 1
    fi
  else
    # Extract from version
    cmd_schema_extract --version "$base" --output-dir "$CACHE_DIR" --format json >/dev/null 2>&1
    base_file="$CACHE_DIR/claude-code-$base.schema.json"
  fi

  # Get compare schema - resolve latest
  local resolved_compare="$compare"
  if [[ "$compare" == "latest" ]]; then
    resolved_compare=$(curl -sL "https://registry.npmjs.org/@anthropic-ai/claude-code/latest" | node -p "JSON.parse(require('fs').readFileSync(0,'utf8')).version" 2>/dev/null)
  fi
  cmd_schema_extract --version "$resolved_compare" --output-dir "$CACHE_DIR" --format json >/dev/null 2>&1
  local compare_file="$CACHE_DIR/claude-code-$resolved_compare.schema.json"

  # Compare using node
  compare_schemas "$base_file" "$compare_file" "$output_format" "$base" "$resolved_compare"
}

# Helper: Compare two schema files
compare_schemas() {
  local base_file="$1"
  local compare_file="$2"
  local output_format="$3"
  local base_name="$4"
  local compare_name="$5"

  node -e '
const fs = require("fs");
const baseSchema = JSON.parse(fs.readFileSync(process.argv[1], "utf8"));
const compareSchema = JSON.parse(fs.readFileSync(process.argv[2], "utf8"));
const outputFormat = process.argv[3];
const baseName = process.argv[4];
const compareName = process.argv[5];

// Get property names
const baseProps = new Set(Object.keys(baseSchema.properties || {}));
const compareProps = new Set(Object.keys(compareSchema.properties || {}));

// Get descriptions - from x-extracted or by extracting from properties
let baseDescriptions = new Set();
let compareDescriptions = new Set();

if (baseSchema["x-extracted"] && baseSchema["x-extracted"].descriptions) {
  baseDescriptions = new Set(baseSchema["x-extracted"].descriptions);
} else if (baseSchema.properties) {
  // Extract descriptions from schemastore-style schema
  for (const [key, val] of Object.entries(baseSchema.properties)) {
    if (val.description) baseDescriptions.add(val.description);
  }
}

if (compareSchema["x-extracted"] && compareSchema["x-extracted"].descriptions) {
  compareDescriptions = new Set(compareSchema["x-extracted"].descriptions);
}

// Build result
const onlyInBase = [...baseProps].filter(p => !compareProps.has(p));
const onlyInCompare = [...compareProps].filter(p => !baseProps.has(p));
const inBoth = [...baseProps].filter(p => compareProps.has(p));
const newDescs = [...compareDescriptions].filter(d => !baseDescriptions.has(d));

const result = {
  base: baseName,
  compare: compareName,
  properties: { onlyInBase, onlyInCompare, inBoth },
  descriptions: {
    baseCount: baseDescriptions.size,
    compareCount: compareDescriptions.size,
    newCount: newDescs.length,
    newDescriptions: newDescs
  }
};

if (outputFormat === "json") {
  console.log(JSON.stringify(result, null, 2));
} else {
  console.log("## Schema Comparison: " + baseName + " vs " + compareName + "\n");

  // If comparing against schemastore (which has properties but no x-extracted)
  if (baseName === "schemastore") {
    console.log("### Schemastore Properties (" + baseProps.size + ")");
    console.log("These settings are officially documented:\n");
    [...baseProps].sort().forEach(p => {
      const desc = baseSchema.properties[p]?.description || "";
      console.log("  - " + p + (desc ? ": " + desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""));
    });
    console.log("");
  }

  // Extracted describe strings from bundle
  if (compareSchema["x-extracted"]) {
    const meta = compareSchema["x-extracted"];
    console.log("### Extracted from " + compareName + " Bundle");
    console.log("  Total describe strings: " + meta.totalDescribeStrings);
    console.log("  Property mappings: " + meta.propertyMappings);
    if (meta.categories) {
      console.log("  Categories: settings=" + meta.categories.settings +
                  ", tools=" + meta.categories.tools +
                  ", internal=" + meta.categories.internal);
    }
    console.log("");
  }

  // Show sample of extracted descriptions that may be undocumented
  console.log("### Sample Extracted Descriptions");
  console.log("Settings-related strings found in bundle (may include undocumented options):\n");

  const settingsDescs = [...compareDescriptions].filter(d => {
    const lower = d.toLowerCase();
    return lower.includes("permission") || lower.includes("hook") || lower.includes("model") ||
           lower.includes("setting") || lower.includes("enable") || lower.includes("disable") ||
           lower.includes("default") || lower.includes("api");
  }).sort().slice(0, 25);

  settingsDescs.forEach(d => console.log("  - " + d));
  if (compareDescriptions.size > 25) {
    console.log("  ... and " + (compareDescriptions.size - 25) + " more (see full extraction)");
  }
}
' "$base_file" "$compare_file" "$output_format" "$base_name" "$compare_name"
}

cmd_schema_diff_help() {
  cat << 'EOF'
Usage: settings-manager schema-diff [options]

Compare schemas between versions or against schemastore.org.

Options:
  --base VERSION       Base version or "schemastore" (default: schemastore)
  --compare VERSION    Version to compare (default: latest)
  --json               Output as JSON instead of text

Examples:
  # Compare latest against schemastore.org (find undocumented settings)
  settings-manager schema-diff

  # Compare two versions
  settings-manager schema-diff --base 2.0.50 --compare 2.0.62

  # Output as JSON
  settings-manager schema-diff --json
EOF
}

# Setup - flag-driven, no auto-detection
cmd_setup() {
  local source_path=""
  local target_path=""
  local hook_system=""
  local scripts_path=""
  local install_global="false"
  local dry_run="false"
  local force="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --source) source_path="$2"; shift 2 ;;
      --target) target_path="$2"; shift 2 ;;
      --hook-system) hook_system="$2"; shift 2 ;;
      --scripts-path) scripts_path="$2"; shift 2 ;;
      --install-global) install_global="true"; shift ;;
      --dry-run) dry_run="true"; shift ;;
      --force) force="true"; shift ;;
      --help|-h) cmd_setup_help; exit 0 ;;
      *) echo -e "${RED}Unknown option: $1${NC}" >&2; cmd_setup_help; exit 1 ;;
    esac
  done

  # Validate required flags
  if [[ -z "$source_path" ]]; then
    echo -e "${RED}Error: --source is required${NC}" >&2
    cmd_setup_help
    exit 1
  fi

  if [[ -z "$target_path" ]]; then
    echo -e "${RED}Error: --target is required${NC}" >&2
    cmd_setup_help
    exit 1
  fi

  if [[ -z "$hook_system" ]]; then
    echo -e "${RED}Error: --hook-system is required${NC}" >&2
    cmd_setup_help
    exit 1
  fi

  # Validate hook system
  case "$hook_system" in
    lefthook|husky|chezmoi|none) ;;
    *)
      echo -e "${RED}Error: Invalid hook system: $hook_system${NC}" >&2
      echo "Valid options: lefthook, husky, chezmoi, none" >&2
      exit 1
      ;;
  esac

  # Default scripts path based on hook system
  if [[ -z "$scripts_path" ]]; then
    case "$hook_system" in
      chezmoi) scripts_path="dot_local/bin" ;;
      *) scripts_path="scripts/claude" ;;
    esac
  fi

  echo -e "${BLUE}Setting up Claude Code JSONC settings...${NC}"
  echo ""
  echo "Configuration:"
  echo "  Source:      $source_path"
  echo "  Target:      $target_path"
  echo "  Hook system: $hook_system"
  echo "  Scripts:     $scripts_path"
  [[ "$install_global" == "true" ]] && echo "  Install:     ~/.local/bin/settings-manager"
  echo ""

  # Get directory containing source file
  local source_dir
  source_dir="$(dirname "$source_path")"

  # 1. Create source JSONC file
  if [[ -f "$source_path" && "$force" != "true" ]]; then
    echo -e "${YELLOW}Skipping: $source_path exists (use --force)${NC}"
  else
    if [[ "$dry_run" == "true" ]]; then
      echo -e "${GRAY}Would create: $source_path${NC}"
    else
      mkdir -p "$source_dir"

      local existing_content="{}"
      if [[ -f "$target_path" ]]; then
        existing_content=$(cat "$target_path")
        echo -e "${GREEN}Converting existing $target_path${NC}"
      fi

      # Determine header based on hook system
      local header
      if [[ "$hook_system" == "chezmoi" ]]; then
        header="// Claude Code Settings (JSONC - comments allowed)
//
// This file is managed by chezmoi. Edit this file, not the target.
// Run 'chezmoi apply' to sync changes.
//
// Schema: https://json.schemastore.org/claude-code-settings.json
"
      else
        header="// Claude Code Settings (JSONC - comments allowed)
//
// This file is the source of truth. Edit this file, not settings.json.
// Changes sync automatically on commit.
//
// Schema: https://json.schemastore.org/claude-code-settings.json
"
      fi

      echo "$header" > "$source_path"

      node -e '
        const input = process.argv[1];
        try {
          const obj = JSON.parse(input);
          obj["$schema"] = "https://json.schemastore.org/claude-code-settings.json";
          const ordered = { "$schema": obj["$schema"] };
          for (const key of Object.keys(obj)) {
            if (key !== "$schema") ordered[key] = obj[key];
          }
          console.log(JSON.stringify(ordered, null, 2));
        } catch {
          console.log("{}");
        }
      ' "$existing_content" >> "$source_path"

      echo -e "${GREEN}Created: $source_path${NC}"
    fi
  fi

  # 2. Setup based on hook system
  case "$hook_system" in
    chezmoi)
      setup_chezmoi "$source_path" "$target_path" "$scripts_path" "$dry_run" "$force"
      ;;
    lefthook)
      setup_git_hooks "$source_path" "$target_path" "$scripts_path" "lefthook" "$dry_run" "$force"
      ;;
    husky)
      setup_git_hooks "$source_path" "$target_path" "$scripts_path" "husky" "$dry_run" "$force"
      ;;
    none)
      echo -e "${GRAY}Skipping hook setup (--hook-system none)${NC}"
      ;;
  esac

  # 3. Install globally if requested
  if [[ "$install_global" == "true" ]]; then
    install_to_path "$dry_run"
  fi

  echo ""
  echo -e "${GREEN}Setup complete!${NC}"
  echo ""

  case "$hook_system" in
    chezmoi)
      echo "Next steps:"
      echo "  1. Edit $source_path"
      echo "  2. Run 'chezmoi apply' to sync"
      echo "  3. Commit your changes"
      ;;
    lefthook|husky)
      echo "Next steps:"
      echo "  1. Edit $source_path"
      echo "  2. Commit - the hook will sync automatically"
      echo "  3. Run 'settings-manager sync' to sync manually"
      ;;
    none)
      echo "Next steps:"
      echo "  1. Edit $source_path"
      echo "  2. Run 'settings-manager sync --source $source_path --target $target_path' to sync"
      ;;
  esac
}

cmd_setup_help() {
  cat << 'EOF'
Usage: settings-manager setup [options]

Required flags:
  --source PATH       Path to create __settings.jsonc
  --target PATH       Path where settings.json lives/will be generated
  --hook-system TYPE  Hook system: lefthook | husky | chezmoi | none

Optional flags:
  --scripts-path PATH Where to put helper scripts (default: scripts/claude)
  --install-global    Install settings-manager to ~/.local/bin
  --dry-run           Preview changes without applying
  --force             Overwrite existing files

Examples:
  # Regular project with lefthook
  settings-manager setup \
    --source .claude/__settings.jsonc \
    --target .claude/settings.json \
    --hook-system lefthook

  # Chezmoi dotfiles (global settings)
  settings-manager setup \
    --source dot_claude/__settings.jsonc \
    --target dot_claude/settings.json \
    --hook-system chezmoi \
    --install-global

  # Stow dotfiles
  settings-manager setup \
    --source claude/__settings.jsonc \
    --target claude/settings.json \
    --hook-system lefthook \
    --scripts-path claude/scripts
EOF
}

# Setup for git hooks (lefthook or husky)
setup_git_hooks() {
  local source_path="$1"
  local target_path="$2"
  local scripts_path="$3"
  local hook_type="$4"
  local dry_run="$5"
  local force="$6"

  # Create sync script
  local sync_script="$scripts_path/settings-sync.sh"
  mkdir -p "$scripts_path"

  if [[ -f "$sync_script" && "$force" != "true" ]]; then
    echo -e "${YELLOW}Skipping: $sync_script exists${NC}"
  else
    if [[ "$dry_run" == "true" ]]; then
      echo -e "${GRAY}Would create: $sync_script${NC}"
    else
      cat > "$sync_script" << SCRIPT
#!/usr/bin/env bash
# Sync $source_path to $target_path
set -euo pipefail

REPO_ROOT="\$(git rev-parse --show-toplevel)"
cd "\$REPO_ROOT"

SOURCE="$source_path"
TARGET="$target_path"

if [[ ! -f "\$SOURCE" ]]; then
  echo "Error: \$SOURCE not found" >&2
  exit 1
fi

# Validate before sync (with AI explanation on error)
export SETTINGS_AI_EXPLAIN=1
if command -v settings-manager &>/dev/null; then
  if ! settings-manager validate --source "\$SOURCE"; then
    echo "Fix the validation errors above, then commit again."
    exit 1
  fi
fi

node -e '
  const fs = require("fs");
  const input = fs.readFileSync(process.argv[1], "utf8");
  let result = "", inString = false, i = 0;
  while (i < input.length) {
    if (!inString && input[i] === "\"") {
      inString = true; result += input[i]; i++; continue;
    }
    if (inString) {
      if (input[i] === "\\\\" && i + 1 < input.length) { result += input[i] + input[i+1]; i += 2; continue; }
      if (input[i] === "\"") inString = false;
      result += input[i]; i++; continue;
    }
    if (input[i] === "/" && i + 1 < input.length) {
      if (input[i+1] === "/") { while (i < input.length && input[i] !== "\\n") i++; continue; }
      if (input[i+1] === "*") { i += 2; while (i+1 < input.length && !(input[i] === "*" && input[i+1] === "/")) i++; i += 2; continue; }
    }
    result += input[i]; i++;
  }
  const obj = JSON.parse(result);
  console.log(JSON.stringify(obj, null, 2));
' "\$SOURCE" > "\${TARGET}.tmp"

mv "\${TARGET}.tmp" "\$TARGET"
echo "Synced: \$SOURCE -> \$TARGET"
SCRIPT
      chmod +x "$sync_script"
      echo -e "${GREEN}Created: $sync_script${NC}"
    fi
  fi

  # Create block script
  local block_script
  block_script="$(dirname "$scripts_path")/git/block-settings-json.sh"
  mkdir -p "$(dirname "$block_script")"

  if [[ -f "$block_script" && "$force" != "true" ]]; then
    echo -e "${YELLOW}Skipping: $block_script exists${NC}"
  else
    if [[ "$dry_run" == "true" ]]; then
      echo -e "${GRAY}Would create: $block_script${NC}"
    else
      local target_pattern
      target_pattern=$(echo "$target_path" | sed 's/\./\\./g' | sed 's/\//\\\//g')
      local source_pattern
      source_pattern=$(echo "$source_path" | sed 's/\./\\./g' | sed 's/\//\\\//g')

      cat > "$block_script" << SCRIPT
#!/usr/bin/env bash
set -euo pipefail

if [[ "\${SETTINGS_BYPASS:-}" == "1" ]]; then
  exit 0
fi

REPO_ROOT="\$(git rev-parse --show-toplevel)"
cd "\$REPO_ROOT"

if git diff --cached --name-only | grep -q "^${target_pattern}\$"; then
  if git diff --cached --name-only | grep -q "^${source_pattern}\$"; then
    exit 0
  fi

  echo ""
  echo "ERROR: Direct edits to $target_path are blocked."
  echo ""
  echo "Edit $source_path instead (supports comments)."
  echo ""
  echo "Bypass (emergency only):"
  echo "  SETTINGS_BYPASS=1 git commit -m \"...\""
  echo ""
  exit 1
fi
SCRIPT
      chmod +x "$block_script"
      echo -e "${GREEN}Created: $block_script${NC}"
    fi
  fi

  # Setup hook configuration
  if [[ "$hook_type" == "lefthook" ]]; then
    setup_lefthook_config "$source_path" "$sync_script" "$block_script" "$dry_run" "$force"
  else
    setup_husky_config "$source_path" "$sync_script" "$block_script" "$dry_run" "$force"
  fi

  # Update .gitattributes
  if [[ "$dry_run" == "true" ]]; then
    echo -e "${GRAY}Would update: .gitattributes${NC}"
  else
    if ! grep -q "$target_path.*linguist-generated" .gitattributes 2>/dev/null; then
      echo "$target_path linguist-generated=true" >> .gitattributes
      echo -e "${GREEN}Updated: .gitattributes${NC}"
    fi
  fi
}

setup_lefthook_config() {
  local source_path="$1"
  local sync_script="$2"
  local block_script="$3"
  local dry_run="$4"
  local force="$5"

  local lefthook_file="lefthook.yml"
  [[ -f "lefthook.yaml" ]] && lefthook_file="lefthook.yaml"

  if [[ "$dry_run" == "true" ]]; then
    echo -e "${GRAY}Would update: $lefthook_file${NC}"
    return
  fi

  local source_pattern
  source_pattern=$(echo "$source_path" | sed 's/\./\\\\./g')

  if [[ ! -f "$lefthook_file" ]]; then
    cat > "$lefthook_file" << YAML
pre-commit:
  jobs:
    - name: block-settings-json
      priority: 0
      glob: "$target_path"
      run: ./$block_script
    - name: sync-settings
      priority: 1
      glob: "$source_path"
      run: |
        ./$sync_script
        git add $target_path
YAML
    echo -e "${GREEN}Created: $lefthook_file${NC}"
    # Auto-install lefthook hooks
    if command -v lefthook &>/dev/null; then
      echo -e "${BLUE}Installing lefthook hooks...${NC}"
      lefthook install
    else
      echo -e "${YELLOW}Note: Run 'lefthook install' to activate hooks${NC}"
    fi
  else
    if grep -q "block-settings-json\|sync-settings" "$lefthook_file" 2>/dev/null; then
      if [[ "$force" != "true" ]]; then
        echo -e "${YELLOW}Skipping: hooks already in $lefthook_file (use --force)${NC}"
        return
      fi
    fi

    echo -e "${YELLOW}Manual step: Add to $lefthook_file:${NC}"
    cat << YAML
pre-commit:
  jobs:
    - name: block-settings-json
      priority: 0
      glob: "$target_path"
      run: ./$block_script
    - name: sync-settings
      priority: 1
      glob: "$source_path"
      run: |
        ./$sync_script
        git add $target_path
YAML
  fi
}

setup_husky_config() {
  local source_path="$1"
  local sync_script="$2"
  local block_script="$3"
  local dry_run="$4"
  local force="$5"

  if [[ "$dry_run" == "true" ]]; then
    echo -e "${GRAY}Would update: .husky/pre-commit${NC}"
    return
  fi

  mkdir -p .husky

  local pre_commit=".husky/pre-commit"
  local source_pattern
  source_pattern=$(echo "$source_path" | sed 's/\./\\\\./g')
  local target_pattern
  target_pattern=$(echo "$target_path" | sed 's/\./\\\\./g')

  if [[ ! -f "$pre_commit" ]]; then
    cat > "$pre_commit" << BASH
#!/usr/bin/env sh
. "\$(dirname -- "\$0")/_/husky.sh"

# Only run if settings files are staged
SETTINGS_JSON_STAGED=\$(git diff --cached --name-only | grep -q "^${target_pattern}\$" && echo "1" || echo "0")
SETTINGS_JSONC_STAGED=\$(git diff --cached --name-only | grep -q "^${source_pattern}\$" && echo "1" || echo "0")

# Exit silently if no settings files staged
if [ "\$SETTINGS_JSON_STAGED" = "0" ] && [ "\$SETTINGS_JSONC_STAGED" = "0" ]; then
  exit 0
fi

# Block direct settings.json edits
if [ "\$SETTINGS_JSON_STAGED" = "1" ]; then
  ./$block_script || exit 1
fi

# Sync if jsonc is staged
if [ "\$SETTINGS_JSONC_STAGED" = "1" ]; then
  ./$sync_script
  git add $target_path
fi
BASH
    chmod +x "$pre_commit"
    echo -e "${GREEN}Created: $pre_commit${NC}"
    # Auto-install husky hooks
    if command -v npx &>/dev/null; then
      echo -e "${BLUE}Installing husky hooks...${NC}"
      npx husky install 2>/dev/null || npx husky init 2>/dev/null || true
    else
      echo -e "${YELLOW}Note: Run 'npx husky install' to activate hooks${NC}"
    fi
  else
    if grep -q "block-settings-json\|settings-sync" "$pre_commit" 2>/dev/null; then
      if [[ "$force" != "true" ]]; then
        echo -e "${YELLOW}Skipping: hooks already in $pre_commit (use --force)${NC}"
        return
      fi
    fi

    echo -e "${YELLOW}Manual step: Add to .husky/pre-commit:${NC}"
    cat << BASH
#!/usr/bin/env sh
. "\$(dirname -- "\$0")/_/husky.sh"

# Only run if settings files are staged
SETTINGS_JSON_STAGED=\$(git diff --cached --name-only | grep -q "^${target_pattern}\$" && echo "1" || echo "0")
SETTINGS_JSONC_STAGED=\$(git diff --cached --name-only | grep -q "^${source_pattern}\$" && echo "1" || echo "0")

# Exit silently if no settings files staged
if [ "\$SETTINGS_JSON_STAGED" = "0" ] && [ "\$SETTINGS_JSONC_STAGED" = "0" ]; then
  exit 0
fi

# Block direct settings.json edits
if [ "\$SETTINGS_JSON_STAGED" = "1" ]; then
  ./$block_script || exit 1
fi

# Sync if jsonc is staged
if [ "\$SETTINGS_JSONC_STAGED" = "1" ]; then
  ./$sync_script
  git add $target_path
fi
BASH
  fi
}

# Setup for chezmoi
setup_chezmoi() {
  local source_path="$1"
  local target_path="$2"
  local scripts_path="$3"
  local dry_run="$4"
  local force="$5"

  # Create run_onchange_ script
  local run_script="run_onchange_after_claude-settings.sh.tmpl"

  if [[ -f "$run_script" && "$force" != "true" ]]; then
    echo -e "${YELLOW}Skipping: $run_script exists${NC}"
  else
    if [[ "$dry_run" == "true" ]]; then
      echo -e "${GRAY}Would create: $run_script${NC}"
    else
      # Determine the chezmoi include path (source_path without leading ./)
      local include_path="${source_path#./}"

      cat > "$run_script" << TMPL
#!/bin/bash
# Sync Claude Code JSONC settings to JSON
# Triggered when content changes
# hash: {{ include "$include_path" | sha256sum }}

set -euo pipefail

# Resolve target path (chezmoi transforms dot_ to .)
TARGET_DIR="\$HOME/.claude"
SOURCE="\$TARGET_DIR/__settings.jsonc"
TARGET="\$TARGET_DIR/settings.json"

if [[ ! -f "\$SOURCE" ]]; then
  echo "Claude settings source not found: \$SOURCE"
  exit 0
fi

echo "Syncing Claude settings..."

# Validate before sync (with AI explanation on error)
export SETTINGS_AI_EXPLAIN=1
if command -v settings-manager &>/dev/null; then
  if ! settings-manager validate --source "\$SOURCE"; then
    echo "Fix the validation errors above, then run: chezmoi apply"
    exit 1
  fi
fi

node -e '
  const fs = require("fs");
  const input = fs.readFileSync(process.argv[1], "utf8");
  let result = "", inString = false, i = 0;
  while (i < input.length) {
    if (!inString && input[i] === "\"") {
      inString = true; result += input[i]; i++; continue;
    }
    if (inString) {
      if (input[i] === "\\\\" && i + 1 < input.length) { result += input[i] + input[i+1]; i += 2; continue; }
      if (input[i] === "\"") inString = false;
      result += input[i]; i++; continue;
    }
    if (input[i] === "/" && i + 1 < input.length) {
      if (input[i+1] === "/") { while (i < input.length && input[i] !== "\\n") i++; continue; }
      if (input[i+1] === "*") { i += 2; while (i+1 < input.length && !(input[i] === "*" && input[i+1] === "/")) i++; i += 2; continue; }
    }
    result += input[i]; i++;
  }
  const obj = JSON.parse(result);
  console.log(JSON.stringify(obj, null, 2));
' "\$SOURCE" > "\${TARGET}.tmp"

mv "\${TARGET}.tmp" "\$TARGET"
echo "Synced: \$SOURCE -> \$TARGET"
TMPL
      chmod +x "$run_script"
      echo -e "${GREEN}Created: $run_script${NC}"
    fi
  fi

  # Update .chezmoiignore
  local target_dir
  target_dir="$(dirname "$target_path")"
  local ignore_pattern="$target_dir/settings.json"

  if [[ "$dry_run" == "true" ]]; then
    echo -e "${GRAY}Would update: .chezmoiignore${NC}"
  else
    if ! grep -q "$ignore_pattern" .chezmoiignore 2>/dev/null; then
      echo "$ignore_pattern" >> .chezmoiignore
      echo -e "${GREEN}Updated: .chezmoiignore${NC}"
    fi
  fi
}

# Install settings-manager to ~/.local/bin
install_to_path() {
  local dry_run="$1"
  local install_dir="$HOME/.local/bin"
  local install_path="$install_dir/settings-manager"

  if [[ "$dry_run" == "true" ]]; then
    echo -e "${GRAY}Would install: $install_path${NC}"
    return
  fi

  mkdir -p "$install_dir"
  cp "$SCRIPT_PATH" "$install_path"
  chmod +x "$install_path"
  echo -e "${GREEN}Installed: $install_path${NC}"

  if [[ ":$PATH:" != *":$install_dir:"* ]]; then
    echo -e "${YELLOW}Note: Add $install_dir to PATH if not already present${NC}"
  fi
}

# ================================================================
# Router
# ================================================================
COMMAND="${1:-help}"
shift || true

case "$COMMAND" in
  setup) cmd_setup "$@" ;;
  sync) cmd_sync "$@" ;;
  check) cmd_check "$@" ;;
  validate) cmd_validate "$@" ;;
  schema-extract) cmd_schema_extract "$@" ;;
  schema-diff) cmd_schema_diff "$@" ;;
  help|--help|-h)
    echo "Usage: settings-manager <command> [options]"
    echo ""
    echo "Commands:"
    echo "  setup           Set up JSONC settings workflow (run 'setup --help' for details)"
    echo "  sync            Sync JSONC to JSON"
    echo "  check           Check if files are in sync"
    echo "  validate        Validate JSONC against schema"
    echo "  schema-extract  Extract schema from Claude Code npm package"
    echo "  schema-diff     Compare schemas between versions"
    echo ""
    echo "Examples:"
    echo "  settings-manager setup --source .claude/__settings.jsonc --target .claude/settings.json --hook-system lefthook"
    echo "  settings-manager sync --source .claude/__settings.jsonc --target .claude/settings.json"
    echo "  settings-manager check --source .claude/__settings.jsonc --target .claude/settings.json"
    echo "  settings-manager validate --source .claude/__settings.jsonc"
    echo "  settings-manager schema-extract --version 2.0.62 --output-dir docs/"
    echo "  settings-manager schema-diff --base schemastore --compare latest"
    ;;
  *)
    echo "Error: Unknown command: $COMMAND" >&2
    echo "Run 'settings-manager help' for usage" >&2
    exit 1
    ;;
esac
