#!/usr/bin/env bash
set -euo pipefail

# Configurable mutex lock to prevent concurrent worktree operations.
# Set WORKTREE_USE_FLOCK=false to disable (for testing/debugging).
WORKTREE_USE_FLOCK="${WORKTREE_USE_FLOCK:-true}"

if [[ "$WORKTREE_USE_FLOCK" == "true" ]]; then
  LOCK_FILE="${TMPDIR:-/tmp}/worktree-script-${USER:-$(id -un)}.lock"
  exec 200>"$LOCK_FILE"
  if ! flock -x -w 60 200; then
    echo "Error: Could not acquire worktree script lock (timeout after 60s)" >&2
    echo "Another worktree command may be running. Wait or check for stuck processes." >&2
    exit 1
  fi
fi

# Allow internal git worktree calls to bypass the guard hook.
export WORKTREE_GUARD_ALLOW_RAW=1

if ! command -v jq >/dev/null 2>&1; then
  echo "Error: jq is required for /worktree" >&2
  exit 1
fi

# Operate on the current working directory's git repository
if ! MAIN_REPO="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  echo "Error: not inside a git repository" >&2
  echo "Run this command from within your project's git repository" >&2
  exit 1
fi
cd "$MAIN_REPO"
REPO_NAME="$(basename "$MAIN_REPO")"
DEFAULT_WORKTREE_ROOT="$(dirname "$MAIN_REPO")/.worktrees/$REPO_NAME"

if mkdir -p "$DEFAULT_WORKTREE_ROOT" >/dev/null 2>&1; then
  PROBE_DIR=$(mktemp -d "$DEFAULT_WORKTREE_ROOT/.probe-XXXXXX" 2>/dev/null || true)
  if [[ -n "${PROBE_DIR:-}" ]]; then
    rmdir "$PROBE_DIR" >/dev/null 2>&1 || true
    WORKTREE_ROOT="$DEFAULT_WORKTREE_ROOT"
  else
    WORKTREE_ROOT="$MAIN_REPO/.worktree/workspaces"
  fi
else
  WORKTREE_ROOT="$MAIN_REPO/.worktree/workspaces"
fi

mkdir -p "$WORKTREE_ROOT" >/dev/null 2>&1 || {
  echo "Error: unable to create worktree root at $WORKTREE_ROOT" >&2
  exit 1
}

BRANCH_PREFIX="worktree"

NOW() {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

slugify() {
  local input="$1"
  if [[ -z "$input" ]]; then
    echo ""
    return
  fi
  python - "$input" <<'PY'
import re, sys, unicodedata
text = sys.argv[1]
text = unicodedata.normalize("NFKD", text).encode("ascii", "ignore").decode("ascii")
text = re.sub(r'[^a-zA-Z0-9]+', '-', text).strip('-').lower()
print(text)
PY
}

# Git config helper functions
wt_set() {
  local name="$1" key="$2" value="$3"
  git config --worktree "worktree.wt.${name}.${key}" "$value"
}

wt_get() {
  local name="$1" key="$2"
  git config --worktree --get "worktree.wt.${name}.${key}" 2>/dev/null || echo ""
}

wt_delete() {
  local name="$1"
  git config --worktree --remove-section "worktree.wt.${name}" 2>/dev/null || true
}

wt_list_names() {
  git config --worktree --get-regexp '^worktree\.wt\.' 2>/dev/null | \
    sed -n 's/^worktree\.wt\.\([^.]*\)\..*$/\1/p' | sort -u
}

wt_exists() {
  local name="$1"
  [[ -n "$(wt_get "$name" "branch")" ]]
}

worktree_path() {
  local name="$1"
  echo "$WORKTREE_ROOT/$name"
}

with_meta() {
  local name="$1"
  if ! wt_exists "$name"; then
    echo "Error: worktree '$name' is not managed" >&2
    exit 1
  fi
}

parse_duration() {
  local spec="$1"
  case "$spec" in
    *h)
      local hours="${spec%h}"
      echo "$hours hours"
      ;;
    *m)
      local mins="${spec%m}"
      echo "$mins minutes"
      ;;
    *d)
      local days="${spec%d}"
      echo "$days days"
      ;;
    *)
      echo "${spec} seconds"
      ;;
  esac
}

lock_state_json() {
  local name="$1"
  local lock_agent
  lock_agent=$(wt_get "$name" "lock_agent")
  if [[ -z "$lock_agent" ]]; then
    echo "null"
    return
  fi

  local now_ts="$(date -u +%s)"
  local state="active"
  local lock_since lock_ttl lock_expires_at lock_reason
  lock_since=$(wt_get "$name" "lock_since")
  lock_ttl=$(wt_get "$name" "lock_ttl")
  lock_expires_at=$(wt_get "$name" "lock_expires_at")
  lock_reason=$(wt_get "$name" "lock_reason")

  if [[ -n "$lock_expires_at" ]]; then
    local exp_ts
    exp_ts=$(date -d "$lock_expires_at" +%s 2>/dev/null || echo 0)
    if [[ "$exp_ts" -ne 0 && "$exp_ts" -lt "$now_ts" ]]; then
      state="expired"
    fi
  fi

  jq -n \
    --arg agent "$lock_agent" \
    --arg since "$lock_since" \
    --arg ttl "$lock_ttl" \
    --arg expires "$lock_expires_at" \
    --arg reason "$lock_reason" \
    --arg state "$state" ' {
      agent: $agent,
      since: $since,
      ttl: $ttl,
      expires_at: $expires,
      reason: $reason,
      state: $state
    }
    | (if $reason == "" then del(.reason) else . end)
    | (if $expires == "" then del(.expires_at) else . end)
  '
}

require_lock_free() {
  local name="$1"
  local lock_json
  lock_json=$(lock_state_json "$name")
  if [[ "$lock_json" != "null" ]]; then
    local state
    state=$(jq -r '.state' <<<"$lock_json")
    if [[ "$state" == "active" ]]; then
      local agent
      agent=$(jq -r '.agent' <<<"$lock_json")
      echo "Error: worktree '$name' locked by $agent" >&2
      exit 1
    fi
  fi
}

lock_command() {
  local name="$1"
  shift
  local agent=""
  local reason=""
  local ttl="6h"
  local force_lock="false"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --agent)
        agent="$2"; shift 2 ;;
      --reason)
        reason="$2"; shift 2 ;;
      --ttl)
        ttl="$2"; shift 2 ;;
      --force)
        force_lock="true"; shift ;;
      *)
        echo "Unknown flag: $1" >&2; exit 1 ;;
    esac
  done
  [[ -n "$agent" ]] || { echo "Error: --agent required" >&2; exit 1; }
  with_meta "$name"

  # Check for existing lock
  local lock_json
  lock_json=$(lock_state_json "$name")
  if [[ "$lock_json" != "null" ]]; then
    local state
    state=$(jq -r '.state' <<<"$lock_json")
    if [[ "${force_lock:-false}" != "true" && "$state" == "active" ]]; then
      echo "Error: worktree '$name' already locked" >&2
      exit 1
    fi
  fi

  # Calculate expiration
  local duration
  duration=$(parse_duration "$ttl")
  local expires
  expires=$(date -u -d "$duration" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || true)

  # Write lock metadata to git config
  wt_set "$name" "lock_agent" "$agent"
  wt_set "$name" "lock_since" "$(NOW)"
  wt_set "$name" "lock_ttl" "$ttl"
  if [[ -n "$expires" ]]; then
    wt_set "$name" "lock_expires_at" "$expires"
  fi
  if [[ -n "$reason" ]]; then
    wt_set "$name" "lock_reason" "$reason"
  fi
  wt_set "$name" "updated_at" "$(NOW)"

  echo "Locked $name for $agent"
}

unlock_command() {
  local name="$1"
  shift
  local agent=""
  local force="false"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --agent)
        agent="$2"; shift 2 ;;
      --force)
        force="true"; shift ;;
      *)
        echo "Unknown flag: $1" >&2; exit 1 ;;
    esac
  done
  with_meta "$name"

  local current_agent
  current_agent=$(wt_get "$name" "lock_agent")
  if [[ -z "$current_agent" ]]; then
    echo "No active lock on $name"
    return
  fi

  if [[ "$force" != "true" && -n "$agent" && "$agent" != "$current_agent" ]]; then
    echo "Error: lock owned by $current_agent" >&2
    exit 1
  fi

  # Remove lock metadata from git config
  git config --worktree --unset "worktree.wt.${name}.lock_agent" 2>/dev/null || true
  git config --worktree --unset "worktree.wt.${name}.lock_since" 2>/dev/null || true
  git config --worktree --unset "worktree.wt.${name}.lock_ttl" 2>/dev/null || true
  git config --worktree --unset "worktree.wt.${name}.lock_expires_at" 2>/dev/null || true
  git config --worktree --unset "worktree.wt.${name}.lock_reason" 2>/dev/null || true
  wt_set "$name" "updated_at" "$(NOW)"

  echo "Unlocked $name"
}

who_command() {
  local name="$1"
  with_meta "$name"
  local info
  info=$(lock_state_json "$name")
  if [[ "$info" == "null" ]]; then
    echo "Worktree $name is not locked"
  else
    echo "$info" | jq
  fi
}

create_command() {
  local name=""
  local issue=""
  local base="dev"
  local agent=""
  local do_lock="false"
  local do_install="false"
  local branch_override=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --issue)
        issue="$2"; shift 2 ;;
      --base)
        base="$2"; shift 2 ;;
      --agent)
        agent="$2"; shift 2 ;;
      --lock)
        do_lock="true"; shift ;;
      --install)
        do_install="true"; shift ;;
      --branch)
        branch_override="$2"; shift 2 ;;
      --*)
        echo "Unknown flag: $1" >&2; exit 1 ;;
      *)
        if [[ -z "$name" ]]; then
          name="$1"; shift
        else
          echo "Unexpected argument: $1" >&2; exit 1
        fi
        ;;
    esac
  done

  if [[ -z "$name" ]]; then
    if [[ -n "$issue" ]]; then
      name="$issue"
    else
      echo "Error: worktree name or --issue required" >&2
      exit 1
    fi
  fi
  local normalized
  normalized="$(slugify "$name")"
  if [[ -z "$normalized" ]]; then
    echo "Error: invalid worktree name" >&2
    exit 1
  fi
  name="$normalized"

  local path branch
  path="$(worktree_path "$name")"
  if wt_exists "$name"; then
    echo "Error: worktree name '$name' already managed" >&2
    exit 1
  fi
  if [[ -e "$path" ]]; then
    echo "Error: path $path already exists" >&2
    exit 1
  fi

  if [[ -z "$branch_override" ]]; then
    local slug_part
    slug_part="$name"
    if [[ -n "$issue" ]]; then
      branch="$BRANCH_PREFIX/${issue}-${slug_part}"
    else
      branch="$BRANCH_PREFIX/${slug_part}"
    fi
    if [[ -n "$agent" ]]; then
      branch="${branch}-${agent}"
    fi
  else
    branch="$branch_override"
  fi

  git fetch origin "$base" >/dev/null 2>&1 || true
  local upstream="origin/$base"
  if ! git rev-parse --verify "$upstream" >/dev/null 2>&1; then
    upstream="$base"
  fi
  git worktree add "$path" -b "$branch" "$upstream"

  local now
  now="$(NOW)"

  # Write metadata to git config
  wt_set "$name" "name" "$name"
  wt_set "$name" "branch" "$branch"
  wt_set "$name" "base" "$base"
  wt_set "$name" "path" "$path"
  wt_set "$name" "created_at" "$now"
  wt_set "$name" "updated_at" "$now"
  if [[ -n "$agent" ]]; then
    wt_set "$name" "agent" "$agent"
  fi
  if [[ -n "$issue" ]]; then
    wt_set "$name" "issue" "$issue"
  fi

  echo "Created worktree $name at $path (branch $branch)"
  if [[ "$do_lock" == "true" && -n "$agent" ]]; then
    lock_command "$name" --agent "$agent"
  fi
}

open_command() {
  local name="$1"
  with_meta "$name"
  local path branch
  path=$(wt_get "$name" "path")
  branch=$(wt_get "$name" "branch")
  echo "$path"
  echo "$branch"
}

status_command() {
  local name="$1"
  with_meta "$name"
  local path branch base
  path=$(wt_get "$name" "path")
  branch=$(wt_get "$name" "branch")
  base=$(wt_get "$name" "base")
  if [[ ! -d "$path" ]]; then
    echo "Error: worktree path missing: $path" >&2
    exit 1
  fi
  local status_output
  status_output=$(git -C "$path" status --short)
  echo "Path: $path"
  echo "Branch: $(git -C "$path" rev-parse --abbrev-ref HEAD)"
  echo "Commit: $(git -C "$path" rev-parse --short HEAD)"
  echo "Tracking: $base"
  if [[ -n "$status_output" ]]; then
    echo "Changes:"
    echo "$status_output"
  else
    echo "Clean"
  fi
}

list_command() {
  local json="false"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json) json="true"; shift ;;
      *) echo "Unknown flag: $1" >&2; exit 1 ;;
    esac
  done

  local names
  names=$(wt_list_names)
  if [[ -z "$names" ]]; then
    if [[ "$json" == "true" ]]; then
      echo '[]'
    else
      echo "No managed worktrees"
    fi
    return
  fi

  local items=()
  while IFS= read -r name; do
    [[ -z "$name" ]] && continue

    # Build metadata JSON from git config
    local meta_json
    meta_json=$(jq -n \
      --arg name "$(wt_get "$name" "name")" \
      --arg branch "$(wt_get "$name" "branch")" \
      --arg base "$(wt_get "$name" "base")" \
      --arg path "$(wt_get "$name" "path")" \
      --arg agent "$(wt_get "$name" "agent")" \
      --arg issue "$(wt_get "$name" "issue")" \
      --arg created_at "$(wt_get "$name" "created_at")" \
      --arg updated_at "$(wt_get "$name" "updated_at")" ' {
        name: $name,
        branch: $branch,
        base: $base,
        path: $path,
        agent: $agent,
        issue: $issue,
        created_at: $created_at,
        updated_at: $updated_at
      }
      | (if .agent == "" then del(.agent) else . end)
      | (if .issue == "" then del(.issue) else . end)
    ')

    # Add lock info if exists
    local lock_json
    lock_json=$(lock_state_json "$name")
    if [[ "$lock_json" != "null" ]]; then
      meta_json=$(jq --argjson lock "$lock_json" '. + {lock: $lock}' <<<"$meta_json")
    fi

    items+=("$meta_json")
  done <<<"$names"

  if [[ "$json" == "true" ]]; then
    if [[ ${#items[@]} -eq 0 ]]; then
      echo '[]'
    else
      printf '%s\n' "${items[@]}" | jq -s '.'
    fi
  else
    printf '%-20s %-40s %-10s %-8s\n' "NAME" "PATH" "BRANCH" "LOCK"
    for entry in "${items[@]}"; do
      local name path branch lock_state lock_agent
      name=$(jq -r '.name' <<<"$entry")
      path=$(jq -r '.path' <<<"$entry")
      branch=$(jq -r '.branch' <<<"$entry")
      lock_state=$(jq -r '.lock.state // "free"' <<<"$entry")
      lock_agent=$(jq -r '.lock.agent // ""' <<<"$entry")
      if [[ "$lock_state" == "free" ]]; then
        printf '%-20s %-40s %-10s %-8s\n' "$name" "$path" "$branch" "free"
      else
        printf '%-20s %-40s %-10s %-8s\n' "$name" "$path" "$branch" "$lock_agent:$lock_state"
      fi
    done
  fi
}

delete_command() {
  local name="$1"
  shift
  local keep_branch="false"
  local force="false"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --keep-branch) keep_branch="true"; shift ;;
      --force) force="true"; shift ;;
      *) echo "Unknown flag: $1" >&2; exit 1 ;;
    esac
  done
  with_meta "$name"
  require_lock_free "$name"

  local branch path base
  branch=$(wt_get "$name" "branch")
  path=$(wt_get "$name" "path")
  base=$(wt_get "$name" "base")

  if [[ "$force" != "true" ]]; then
    if ! git merge-base --is-ancestor "$branch" "origin/$base" >/dev/null 2>&1; then
      echo "Warning: branch $branch not merged into $base" >&2
      echo "Use --force to delete anyway" >&2
      exit 1
    fi
  fi

  git worktree remove "$path" --force >/dev/null 2>&1 || rm -rf "$path"
  if [[ "$keep_branch" != "true" ]]; then
    git branch -D "$branch" >/dev/null 2>&1 || true
  fi

  # Remove all metadata from git config
  wt_delete "$name"

  echo "Deleted worktree $name"
}

prune_command() {
  local merged="false"
  local stale_hours=""
  local force="false"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --merged) merged="true"; shift ;;
      --stale)
        stale_hours="$2"; shift 2 ;;
      --force)
        force="true"; shift ;;
      *) echo "Unknown flag: $1" >&2; exit 1 ;;
    esac
  done

  local removed=0
  local candidates=0
  local names
  names=$(wt_list_names)

  if [[ -z "$names" ]]; then
    echo "No managed worktrees"
    return
  fi

  while IFS= read -r name; do
    [[ -z "$name" ]] && continue

    local branch base updated
    branch=$(wt_get "$name" "branch")
    base=$(wt_get "$name" "base")
    updated=$(wt_get "$name" "updated_at")
    [[ -z "$updated" ]] && updated=$(wt_get "$name" "created_at")

    local should_delete="false"

    if [[ "$merged" == "true" ]]; then
      if git merge-base --is-ancestor "$branch" "origin/$base" >/dev/null 2>&1; then
        should_delete="true"
      fi
    fi

    if [[ -n "$stale_hours" ]]; then
      local updated_ts
      updated_ts=$(date -d "$updated" +%s 2>/dev/null || echo 0)
      local cutoff
      cutoff=$(date -d "-$stale_hours hours" +%s)
      if [[ "$updated_ts" -ne 0 && "$updated_ts" -lt "$cutoff" ]]; then
        should_delete="true"
      fi
    fi

    if [[ "$should_delete" == "true" ]]; then
      if [[ "$force" == "true" ]]; then
        delete_command "$name" --force
        ((removed++))
      else
        echo "Candidate for pruning: $name ($branch)"
        ((candidates++))
      fi
    fi
  done <<<"$names"

  if [[ "$force" == "true" ]]; then
    echo "Pruned $removed worktrees"
  else
    if [[ "$candidates" -gt 0 ]]; then
      echo "Use --force to delete candidates"
    else
      echo "No prune candidates"
    fi
  fi
}

doctor_command() {
  local issues=0
  local names
  names=$(wt_list_names)

  if [[ -z "$names" ]]; then
    echo "No managed worktrees"
    return
  fi

  while IFS= read -r name; do
    [[ -z "$name" ]] && continue

    local path branch
    path=$(wt_get "$name" "path")
    branch=$(wt_get "$name" "branch")

    if [[ ! -d "$path" ]]; then
      echo "Missing path for $name: $path"
      ((issues++))
    fi
    if ! git rev-parse --verify "$branch" >/dev/null 2>&1; then
      echo "Branch missing for $name: $branch"
      ((issues++))
    fi
  done <<<"$names"

  if [[ "$issues" -eq 0 ]]; then
    echo "All worktrees healthy"
  else
    echo "$issues issue(s) detected"
  fi
}

usage() {
  cat <<'HELP'
Usage: /worktree <command> [options]

Core:
  list [--json]
  status <name>
  open <name>
  create <name> [--issue N] [--base dev] [--agent ID] [--lock] [--branch NAME]
  delete <name> [--keep-branch] [--force]
  prune [--merged] [--stale HOURS] [--force]
  doctor

Locks & ownership:
  lock <name> --agent ID [--reason TEXT] [--ttl 6h] [--force]
  unlock <name> [--agent ID] [--force]
  who <name>
HELP
}

case "${1:-}" in
  list) shift; list_command "$@" ;;
  create) shift; create_command "$@" ;;
  open) shift; open_command "$1" ;;
  status) shift; status_command "$1" ;;
  delete) shift; delete_command "$@" ;;
  prune) shift; prune_command "$@" ;;
  lock) shift; lock_command "$@" ;;
  unlock) shift; unlock_command "$@" ;;
  who) shift; who_command "$1" ;;
  doctor) shift; doctor_command "$@" ;;
  ""|-h|--help|help)
    usage ;;
  *)
    echo "Unknown command: $1" >&2
    usage
    exit 1 ;;
esac
