#!/usr/bin/env bash
set -euo pipefail

# Check for required dependency
if ! command -v gh >/dev/null 2>&1; then
  echo "Error: gh CLI is required for /issue" >&2
  exit 1
fi

# Use current working directory's git repo
if ! MAIN_REPO="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  echo "Error: Not in a git repository" >&2
  exit 1
fi
cd "$MAIN_REPO"

# =============================================================================
# Color codes
# =============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# =============================================================================
# GitHub Issue Operations
# =============================================================================

# Create a GitHub issue with labels and metadata
#
# @param $1 TITLE       - Issue title (required)
# @param $2 DESCRIPTION - Issue description (optional)
# @param $3 LABELS      - Comma-separated labels (optional)
# @param $4 PRIORITY    - Priority: high|medium|low (default: medium)
#
# @return Prints issue number to stdout
#
# Usage: gh_create_issue TITLE DESCRIPTION LABELS PRIORITY
gh_create_issue() {
    local title="$1"
    local description="${2:-}"
    local labels="${3:-}"
    local priority="${4:-medium}"

    # Build label list
    local all_labels="ai-task,priority:${priority}"
    if [[ -n "$labels" ]]; then
        all_labels="${all_labels},${labels}"
    fi

    # Add status:available by default
    all_labels="${all_labels},status:available"

    # Create issue body
    local body="${description}"
    if [[ -z "$body" ]]; then
        body="No description provided."
    fi

    # Create issue via gh CLI
    local issue_url=$(gh issue create \
        --title "$title" \
        --body "$body" \
        --label "$all_labels" 2>&1)

    if [[ $? -ne 0 ]]; then
        echo -e "${RED}âŒ Failed to create issue: ${issue_url}${NC}" >&2
        return 1
    fi

    # Extract issue number from URL
    local issue_number=$(echo "$issue_url" | grep -oP '/issues/\K[0-9]+')

    echo "$issue_number"
}

# List GitHub issues with optional filters
#
# @param $1 STATE    - Issue state: open|closed|all (default: open)
# @param $2 LABEL    - Filter by label (optional)
# @param $3 PRIORITY - Filter by priority: high|medium|low (optional)
#
# @return Prints formatted issue list
#
# Usage: gh_list_issues STATE LABEL PRIORITY
gh_list_issues() {
    local state="${1:-open}"
    local label="${2:-}"
    local priority="${3:-}"

    # Build gh command
    local cmd="gh issue list --state=$state --limit=100"

    # Add label filter if specified
    if [[ -n "$label" ]]; then
        cmd="$cmd --label=$label"
    fi

    # Add priority filter if specified
    if [[ -n "$priority" ]]; then
        cmd="$cmd --label=priority:$priority"
    fi

    # Execute and format
    eval "$cmd"
}

# Fetch actionable issues for task execution
# Returns issues that are: open, not in-progress, not wontfix, not closed
#
# @return Prints JSON array of actionable issues
#
# Usage: gh_fetch_actionable_issues
gh_fetch_actionable_issues() {
    # Fetch all open issues with ai-task label
    gh issue list \
        --state=open \
        --label=ai-task \
        --limit=100 \
        --json number,title,labels,body,state \
        --jq '[.[] | select(
            (.labels | map(.name) | contains(["status:in-progress"]) | not) and
            (.labels | map(.name) | contains(["status:completed"]) | not) and
            (.labels | map(.name) | contains(["wontfix"]) | not) and
            (.state == "OPEN")
        )]'
}

# View detailed issue information
#
# @param $1 ISSUE_NUMBER - Issue number (required)
#
# @return Prints formatted issue details
#
# Usage: gh_view_issue ISSUE_NUMBER
gh_view_issue() {
    local issue_number="$1"

    gh issue view "$issue_number"
}

# Add comment to issue
#
# @param $1 ISSUE_NUMBER - Issue number (required)
# @param $2 COMMENT      - Comment text (required)
#
# Usage: gh_comment_issue ISSUE_NUMBER COMMENT
gh_comment_issue() {
    local issue_number="$1"
    local comment="$2"

    gh issue comment "$issue_number" --body "$comment"
}

# Close an issue
#
# @param $1 ISSUE_NUMBER - Issue number (required)
# @param $2 COMMENT      - Optional closing comment
#
# Usage: gh_close_issue ISSUE_NUMBER [COMMENT]
gh_close_issue() {
    local issue_number="$1"
    local comment="${2:-}"

    if [[ -n "$comment" ]]; then
        gh issue close "$issue_number" --comment "$comment"
    else
        gh issue close "$issue_number"
    fi
}

# Reopen a closed issue
#
# @param $1 ISSUE_NUMBER - Issue number (required)
# @param $2 COMMENT      - Optional reopening comment
#
# Usage: gh_reopen_issue ISSUE_NUMBER [COMMENT]
gh_reopen_issue() {
    local issue_number="$1"
    local comment="${2:-}"

    if [[ -n "$comment" ]]; then
        gh issue reopen "$issue_number" --comment "$comment"
    else
        gh issue reopen "$issue_number"
    fi
}

# Manage issue labels (add/remove atomically)
#
# @param $1 ISSUE_NUMBER - Issue number (required)
# @param $2 ADD_LABELS   - Comma-separated labels to add (optional)
# @param $3 REMOVE_LABELS - Comma-separated labels to remove (optional)
#
# Usage: gh_manage_labels ISSUE_NUMBER ADD_LABELS REMOVE_LABELS
gh_manage_labels() {
    local issue_number="$1"
    local add_labels="${2:-}"
    local remove_labels="${3:-}"

    local cmd="gh issue edit $issue_number"

    if [[ -n "$add_labels" ]]; then
        cmd="$cmd --add-label \"$add_labels\""
    fi

    if [[ -n "$remove_labels" ]]; then
        cmd="$cmd --remove-label \"$remove_labels\""
    fi

    eval "$cmd"
}

# =============================================================================
# Utility Functions
# =============================================================================

# Parse key=value arguments into associative array
#
# @param $@ - Arguments in key=value format
#
# Usage: parse_args "$@"
parse_args() {
    declare -gA ARGS

    for arg in "$@"; do
        if [[ "$arg" == *"="* ]]; then
            key="${arg%%=*}"
            value="${arg#*=}"
            # Remove quotes if present
            value="${value%\"}"
            value="${value#\"}"
            ARGS["$key"]="$value"
        fi
    done
}

# Format relative time from ISO timestamp
#
# @param $1 TIMESTAMP - ISO 8601 timestamp
#
# Usage: relative_time "2025-10-02T09:00:00Z"
relative_time() {
    local timestamp="$1"
    local now=$(date +%s)
    local then=$(date -d "$timestamp" +%s 2>/dev/null || echo "$now")
    local diff=$((now - then))

    if [[ $diff -lt 60 ]]; then
        echo "${diff}s ago"
    elif [[ $diff -lt 3600 ]]; then
        echo "$((diff / 60))m ago"
    elif [[ $diff -lt 86400 ]]; then
        echo "$((diff / 3600))h ago"
    else
        echo "$((diff / 86400))d ago"
    fi
}

# =============================================================================
# Command Functions
# =============================================================================

create_command() {
    # Parse arguments
    parse_args "$@"

    # Extract parameters
    local TITLE="${ARGS[issue-title]:-}"
    local DESCRIPTION="${ARGS[description]:-}"
    local LABELS="${ARGS[labels]:-}"
    local PRIORITY="${ARGS[priority]:-medium}"

    # Validate required parameters
    if [[ -z "$TITLE" ]]; then
        echo -e "${RED}âŒ Error: issue-title is required${NC}" >&2
        echo "Usage: /issue create issue-title=\"...\" [description=\"...\"] [labels=\"...\"] [priority=high|medium|low]" >&2
        exit 2
    fi

    # Validate priority
    case "$PRIORITY" in
        high|medium|low) ;;
        *)
            echo -e "${YELLOW}âš ï¸  Invalid priority '$PRIORITY', defaulting to 'medium'${NC}" >&2
            PRIORITY="medium"
            ;;
    esac

    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}  Creating GitHub Issue${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"

    # Display parameters
    echo -e "${CYAN}Title:${NC}       $TITLE"
    echo -e "${CYAN}Priority:${NC}    $PRIORITY"
    if [[ -n "$LABELS" ]]; then
        echo -e "${CYAN}Labels:${NC}      $LABELS"
    fi
    if [[ -n "$DESCRIPTION" ]]; then
        echo -e "${CYAN}Description:${NC} ${DESCRIPTION:0:60}..."
    fi
    echo

    # Create issue
    echo -e "${BLUE}ðŸ“ Creating issue on GitHub...${NC}"

    local ISSUE_NUMBER=$(gh_create_issue "$TITLE" "$DESCRIPTION" "$LABELS" "$PRIORITY")

    if [[ $? -ne 0 ]]; then
        echo -e "${RED}âŒ Failed to create issue${NC}" >&2
        exit 1
    fi

    echo -e "${GREEN}âœ“ Issue created${NC}\n"

    # Display result
    local ISSUE_URL=$(gh repo view --json url -q .url)/issues/${ISSUE_NUMBER}

    echo -e "${GREEN}âœ… Issue #${ISSUE_NUMBER} created successfully!${NC}"
    echo
    echo -e "  ${CYAN}Issue:${NC}  #${ISSUE_NUMBER}"
    echo -e "  ${CYAN}URL:${NC}    ${ISSUE_URL}"
    echo -e "  ${CYAN}Labels:${NC} ai-task, priority:${PRIORITY}, status:available"
    if [[ -n "$LABELS" ]]; then
        echo -e "           ${LABELS}"
    fi
    echo
    echo -e "${GRAY}Next steps:${NC}"
    echo -e "  â€¢ Execute work: ${BLUE}/task handle ${ISSUE_NUMBER}${NC}"
    echo -e "  â€¢ View details: ${BLUE}/issue view ${ISSUE_NUMBER}${NC}"
    echo
}

list_command() {
    # Parse flags
    local STATE="open"
    local LABEL=""
    local PRIORITY=""

    for arg in "$@"; do
        case "$arg" in
            --state=*)
                STATE="${arg#*=}"
                ;;
            --label=*)
                LABEL="${arg#*=}"
                ;;
            --priority=*)
                PRIORITY="${arg#*=}"
                ;;
            *)
                ;;
        esac
    done

    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}  GitHub Issues${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"

    # Display filters
    echo -e "${GRAY}Filters:${NC} state=$STATE"
    if [[ -n "$LABEL" ]]; then
        echo -e "         label=$LABEL"
    fi
    if [[ -n "$PRIORITY" ]]; then
        echo -e "         priority=$PRIORITY"
    fi
    echo

    # List issues
    gh_list_issues "$STATE" "$LABEL" "$PRIORITY"
}

fetch_command() {
    # Fetch actionable issues
    # Returns JSON array of issues suitable for task execution
    gh_fetch_actionable_issues
}

view_command() {
    # Get issue number
    local ISSUE_NUMBER="${1:-}"

    if [[ -z "$ISSUE_NUMBER" ]]; then
        echo -e "${RED}âŒ Error: issue number is required${NC}" >&2
        echo "Usage: /issue view <issue-number>" >&2
        exit 2
    fi

    # View issue
    gh_view_issue "$ISSUE_NUMBER"
}

comment_command() {
    # Get issue number and comment
    local ISSUE_NUMBER="${1:-}"
    local COMMENT="${2:-}"

    if [[ -z "$ISSUE_NUMBER" ]] || [[ -z "$COMMENT" ]]; then
        echo -e "${RED}âŒ Error: issue number and comment are required${NC}" >&2
        echo "Usage: /issue comment <issue-number> \"<comment>\"" >&2
        exit 2
    fi

    echo -e "${BLUE}ðŸ“ Adding comment to issue #${ISSUE_NUMBER}...${NC}"

    gh_comment_issue "$ISSUE_NUMBER" "$COMMENT"

    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}âœ“ Comment added${NC}"
    else
        echo -e "${RED}âŒ Failed to add comment${NC}" >&2
        exit 1
    fi
}

close_command() {
    # Get issue number and optional comment
    local ISSUE_NUMBER="${1:-}"
    local COMMENT="${2:-}"

    if [[ -z "$ISSUE_NUMBER" ]]; then
        echo -e "${RED}âŒ Error: issue number is required${NC}" >&2
        echo "Usage: /issue close <issue-number> [\"<comment>\"]" >&2
        exit 2
    fi

    echo -e "${BLUE}ðŸ”’ Closing issue #${ISSUE_NUMBER}...${NC}"

    gh_close_issue "$ISSUE_NUMBER" "$COMMENT"

    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}âœ“ Issue closed${NC}"
    else
        echo -e "${RED}âŒ Failed to close issue${NC}" >&2
        exit 1
    fi
}

reopen_command() {
    # Get issue number and optional comment
    local ISSUE_NUMBER="${1:-}"
    local COMMENT="${2:-}"

    if [[ -z "$ISSUE_NUMBER" ]]; then
        echo -e "${RED}âŒ Error: issue number is required${NC}" >&2
        echo "Usage: /issue reopen <issue-number> [\"<comment>\"]" >&2
        exit 2
    fi

    echo -e "${BLUE}ðŸ”“ Reopening issue #${ISSUE_NUMBER}...${NC}"

    gh_reopen_issue "$ISSUE_NUMBER" "$COMMENT"

    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}âœ“ Issue reopened${NC}"
    else
        echo -e "${RED}âŒ Failed to reopen issue${NC}" >&2
        exit 1
    fi
}

label_command() {
    # Parse arguments
    local ISSUE_NUMBER="${1:-}"
    local ADD_LABELS=""
    local REMOVE_LABELS=""

    if [[ -z "$ISSUE_NUMBER" ]]; then
        echo -e "${RED}âŒ Error: issue number is required${NC}" >&2
        echo "Usage: /issue label <issue-number> [--add=label1,label2] [--remove=label1,label2]" >&2
        exit 2
    fi

    shift  # Remove issue number from args

    for arg in "$@"; do
        case "$arg" in
            --add=*)
                ADD_LABELS="${arg#*=}"
                ;;
            --remove=*)
                REMOVE_LABELS="${arg#*=}"
                ;;
            *)
                ;;
        esac
    done

    if [[ -z "$ADD_LABELS" ]] && [[ -z "$REMOVE_LABELS" ]]; then
        echo -e "${RED}âŒ Error: must specify --add or --remove${NC}" >&2
        echo "Usage: /issue label <issue-number> [--add=label1,label2] [--remove=label1,label2]" >&2
        exit 2
    fi

    echo -e "${BLUE}ðŸ·ï¸  Managing labels for issue #${ISSUE_NUMBER}...${NC}"

    if [[ -n "$ADD_LABELS" ]]; then
        echo -e "${GRAY}  Adding: ${ADD_LABELS}${NC}"
    fi
    if [[ -n "$REMOVE_LABELS" ]]; then
        echo -e "${GRAY}  Removing: ${REMOVE_LABELS}${NC}"
    fi

    gh_manage_labels "$ISSUE_NUMBER" "$ADD_LABELS" "$REMOVE_LABELS"

    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}âœ“ Labels updated${NC}"
    else
        echo -e "${RED}âŒ Failed to update labels${NC}" >&2
        exit 1
    fi
}

usage() {
    cat <<'HELP'
Usage: /issue <command> [options]

GitHub issue management for task orchestration

Commands:
  create                Create new GitHub issue
  list, ls              List issues with optional filters
  fetch                 Fetch actionable issues (internal)
  view                  View detailed issue information
  comment               Add comment to issue
  close                 Close an issue
  reopen                Reopen a closed issue
  label                 Manage issue labels
  help                  Show this help message

Examples:
  # Create issue
  /issue create issue-title="Add dark mode" \
    description="Implement dark mode" \
    labels="enhancement,frontend" \
    priority=high

  # List issues
  /issue list
  /issue list --state=open --label=bug
  /issue list --priority=high

  # View issue
  /issue view 141

  # Fetch actionable issues
  /issue fetch

  # Comment on issue
  /issue comment 141 "Working on this"

  # Manage labels
  /issue label 141 --add=bug --remove=enhancement

  # Close/reopen
  /issue close 141
  /issue reopen 141

For more details, see .claude/_spec/task-orchestration-v2.1.md
HELP
}

# =============================================================================
# Command Router
# =============================================================================

case "${1:-}" in
  create) shift; create_command "$@" ;;
  list|ls) shift; list_command "$@" ;;
  fetch) shift; fetch_command "$@" ;;
  view) shift; view_command "$@" ;;
  comment) shift; comment_command "$@" ;;
  close) shift; close_command "$@" ;;
  reopen) shift; reopen_command "$@" ;;
  label) shift; label_command "$@" ;;
  ""|-h|--help|help)
    usage ;;
  *)
    echo "Unknown command: $1" >&2
    usage
    exit 1 ;;
esac
